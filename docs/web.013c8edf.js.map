{"version":3,"sources":["../core/scanner.ts","../core/error.ts","../core/scanner.func.ts","../node_modules/base64-js/index.js","../node_modules/ieee754/index.js","../node_modules/isarray/index.js","../node_modules/buffer/index.js","../node_modules/pad/dist/pad.esm.js","../core/parser.symboltable.ts","../core/parser.definitions.ts","../core/parser.expression.ts","../core/parser.funcs.ts","../core/parser.ts","../core/assertNever.ts","../core/emitter.utils.ts","../core/emitter.helpers.functionsignature.ts","../core/emitter.helpers.ts","../core/emitter.scalar.storeload.ts","../core/emitter.scalar.ts","../core/emitter.expressionsandtypes.ts","../core/emitter.functionscode.ts","../core/emitter.helpers.trap.ts","../core/emitter.ts","ast.ts","index.ts"],"names":["_pad$1","_typeof","obj","Symbol","iterator","constructor","prototype","createCommonjsModule","fn","module","exports","_pad","clone_1","clone","parent","circular","depth","filter","allParents","allChildren","useBuffer","Buffer","_clone","Infinity","child","proto","__isArray","__isRegExp","RegExp","source","__getRegExpFlags","lastIndex","__isDate","Date","getTime","isBuffer","allocUnsafe","length","copy","Object","getPrototypeOf","create","index","indexOf","push","i","attrs","getOwnPropertyDescriptor","set","__objToStr","o","toString","call","re","flags","global","ignoreCase","multiline","clonePrototype","c","defaults","options","_defaults","keys","forEach","key","combining","DEFAULTS","nul","control","config","opts","str","wcswidth","wcwidth","s","n","charCodeAt","ucs","bisearch","min","mid","max","Math","floor","text","escapecolor","invert","padlength","textnocolors","_ref","strip","colors","replace","fixed_width","wcwidth_options","substr","repeat"],"mappings":"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AAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,KAAQ,MAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,OAAS,CAAC,MAAQ,O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","file":"web.013c8edf.js","sourceRoot":"../web","sourcesContent":["import { Token } from \"./scanner.func\";\n\nexport class Scanner {\n  private currentToken: Token;\n  constructor(private readonly scanner: () => Token) {\n    this.currentToken = this.scanner();\n  }\n\n  current() {\n    return this.currentToken;\n  }\n\n  private readonly pushedBackTokens: Token[] = [];\n\n  readNext() {\n    const pushedBackToken = this.pushedBackTokens.shift();\n\n    const currentToken = pushedBackToken ? pushedBackToken : this.scanner();\n\n    /*\n    this.controlPoints.forEach((controlPoint) =>\n      controlPoint.push(currentToken)\n    );\n    */\n\n    this.currentToken = currentToken;\n  }\n\n  pushBack(token: Token) {\n    this.pushedBackTokens.unshift(this.current());\n    this.currentToken = token;\n  }\n\n  nextToken() {\n    const token = this.current();\n    this.readNext();\n    const next = this.current();\n    this.pushBack(token);\n    return next;\n  }\n\n  /*\n  private readonly controlPoints: Token[][] = [];\n\n  public makeControlPoint() {\n    this.controlPoints.push([this.currentToken]);\n  }\n  public clearControlPoint() {\n    const dataInControlPoint = this.controlPoints.pop();\n    if (!dataInControlPoint) {\n      throw new Error(`No saved control point!`);\n    }\n  }\n  public rollbackControlPoint() {\n    const dataInControlPoint = this.controlPoints.pop();\n    if (!dataInControlPoint) {\n      throw new Error(`No saved control point!`);\n    }\n\n    // Clear other control points\n    this.controlPoints.forEach((controlPoint) => {\n      dataInControlPoint.forEach(() => controlPoint.pop());\n    });\n\n    dataInControlPoint\n      .slice()\n      .reverse()\n      .forEach((token) => this.pushedBackTokens.unshift(token));\n    this.readNext();\n  }\n  */\n}\n\n/*\n\n  *   *    \na b c d e f g \n\n*/\n","export interface TokenLocation {\n  readonly pos: number;\n  readonly line: number;\n  readonly length: number;\n}\nexport class ScannerError extends Error {\n  constructor(str: string, public readonly location: TokenLocation) {\n    super(str);\n  }\n}\n\nexport class ParserError extends Error {\n  constructor(str: string, public readonly location: TokenLocation) {\n    super(str);\n    // console.info(location);\n  }\n}\n\n/** TODO: Emit errors, do not throw */\nexport class CheckerError extends Error {\n  constructor(str: string, public readonly location: TokenLocation) {\n    super(str);\n  }\n}\n\nexport class SymbolTableError extends Error {\n  constructor(str: string, public readonly location: TokenLocation) {\n    super(str);\n  }\n}\n","import { TokenLocation, ScannerError } from \"./error\";\n\nexport const BINARY_OPERATORS = [\n  \"*\",\n  \"/\",\n  \"%\",\n  \"+\",\n  \"-\",\n  \"<<\",\n  \">>\",\n  \"<\",\n  \">\",\n  \"<=\",\n  \">=\",\n  \"==\",\n  \"!=\",\n  \"&\",\n  \"^\",\n  \"|\",\n  \"&&\",\n  \"||\",\n] as const;\nexport type BinaryOperator = typeof BINARY_OPERATORS[number];\n\nexport const ASSIGNMENT_OPERATORS = [\n  \"=\",\n  \"*=\",\n  \"/=\",\n  \"%=\",\n  \"+=\",\n  \"-=\",\n  \"<<=\",\n  \">>=\",\n  \"&=\",\n  \"^=\",\n  \"|=\",\n] as const;\n\nexport type AssignmentOperator = typeof ASSIGNMENT_OPERATORS[number];\n\nexport const PUNCTUATORS = [\n  ...BINARY_OPERATORS,\n  ...ASSIGNMENT_OPERATORS,\n\n  \"[\",\n  \"]\",\n  \"(\",\n  \")\",\n  \".\",\n  \"->\",\n  \"++\",\n  \"--\",\n\n  \"~\",\n  \"!\",\n\n  \"?\",\n  \":\",\n\n  \",\",\n  \"{\",\n  \"}\",\n  \";\",\n  \"...\",\n] as const;\n\nexport type Punctuator = typeof PUNCTUATORS[number];\n\nif (\n  PUNCTUATORS.filter((op1, idx1) =>\n    PUNCTUATORS.find((op2, idx2) => op1 === op2 && idx1 !== idx2)\n  ).length > 0\n) {\n  throw new Error(\"Duplicates found\");\n}\n\nexport const TYPE_SPECIFIERS_ARITHMETIC = [\n  \"char\",\n  \"short\",\n  \"int\",\n  \"long\",\n  \"float\",\n  \"double\",\n] as const;\nexport type TypeSpecifierArithmetic = typeof TYPE_SPECIFIERS_ARITHMETIC[number];\n\nexport const TYPE_SPECIFIERS_UNDERSCORE = [\n  \"_Bool\",\n  \"_Complex\",\n  \"_Imaginary\",\n] as const;\nexport type TypeSpecifierUnderscore = typeof TYPE_SPECIFIERS_UNDERSCORE[number];\n\nexport const TYPE_SIGNED_UNSIGNED = [\"signed\", \"unsigned\"] as const;\nexport type TypeSignedUnsigned = typeof TYPE_SIGNED_UNSIGNED[number];\n\nexport const TYPE_QUALIFIERS = [\"restrict\", \"const\", \"volatile\"] as const;\n\nexport type TypeQualifier = typeof TYPE_QUALIFIERS[number];\n\nexport const STORAGE_CLASSES = [\n  \"typedef\",\n  \"extern\",\n  \"static\",\n  \"auto\",\n  \"register\",\n] as const;\nexport type StorageClass = typeof STORAGE_CLASSES[number];\n\nexport const KEYWORDS = [\n  ...TYPE_SPECIFIERS_ARITHMETIC,\n  ...TYPE_SPECIFIERS_UNDERSCORE,\n  ...TYPE_SIGNED_UNSIGNED,\n  ...TYPE_QUALIFIERS,\n  ...STORAGE_CLASSES,\n\n  \"break\",\n  \"case\",\n\n  \"continue\",\n  \"default\",\n  \"do\",\n\n  \"else\",\n  \"enum\",\n\n  \"for\",\n  \"goto\",\n  \"if\",\n\n  \"return\",\n\n  \"sizeof\",\n\n  \"struct\",\n  \"switch\",\n\n  \"union\",\n\n  \"void\",\n  \"while\",\n\n  \"inline\",\n] as const;\n\nexport type Keyword = typeof KEYWORDS[number];\n\nexport type Token = (\n  | {\n      type: Keyword;\n    }\n  | {\n      type: \"identifier\";\n      text: string;\n    }\n  | {\n      type: \"const-expression\";\n      subtype: \"int\" | \"float\" | \"char\";\n      value: number;\n    }\n  | {\n      type: \"string-literal\";\n      value: string;\n    }\n  | {\n      type: Punctuator;\n    }\n  | {\n      type: \"end\";\n    }\n) &\n  TokenLocation;\n\nexport function createScannerFunc(str: string) {\n  let pos = 0;\n  const end = str.length;\n\n  function current(): string | undefined {\n    return str[pos];\n  }\n  function lookAhead(charCount: number) {\n    return pos + charCount < end ? str[pos + charCount] : undefined;\n  }\n  function next() {\n    return lookAhead(1);\n  }\n  let lineNumber = 1;\n  let inlinePos = 1;\n  function incPos(n = 1) {\n    for (let i = 0; i < n; i++) {\n      // TODO: update linenum and pos in line\n      if (current() === \"\\n\") {\n        lineNumber += 1;\n        inlinePos = 1;\n      } else {\n        inlinePos++;\n      }\n      pos++;\n    }\n  }\n\n  let savedPos = pos;\n  let savedInlinePos = inlinePos;\n  let savedLineNumber = lineNumber;\n  function saveLocation() {\n    savedPos = pos;\n    savedInlinePos = inlinePos;\n    savedLineNumber = lineNumber;\n  }\n  function sliceFromSavedPoint() {\n    return str.slice(savedPos, pos);\n  }\n  function savedLocation(): TokenLocation {\n    return {\n      pos: savedInlinePos,\n      line: savedLineNumber,\n      length: pos - savedPos,\n    };\n  }\n\n  function isWhitespace(char: string | undefined) {\n    return char === \" \" || char === \"\\n\" || char === \"\\r\" || char === \"\\t\";\n  }\n\n  function throwError(text: string): never {\n    throw new ScannerError(`${text}`, savedLocation());\n  }\n\n  function scanWhitespace() {\n    while (pos < end && isWhitespace(current())) {\n      incPos();\n    }\n    if (current() === \"/\" && next() === \"*\") {\n      incPos(2);\n      while (true) {\n        if (current() === \"*\" && next() === \"/\") {\n          incPos(2);\n          break;\n        }\n        incPos();\n      }\n      scanWhitespace();\n    }\n\n    if (current() === \"/\" && next() === \"/\") {\n      incPos(2);\n      while (current() !== \"\\n\") {\n        incPos();\n      }\n      scanWhitespace();\n    }\n  }\n\n  function isDigit(char: string | undefined) {\n    return (\n      char !== undefined && char.length === 1 && \"0123456789\".indexOf(char) > -1\n    );\n  }\n  function isHexDigit(char: string | undefined) {\n    return (\n      char !== undefined &&\n      char.length === 1 &&\n      \"0123456789abcdefABCDEF\".indexOf(char) > -1\n    );\n  }\n\n  function isLetter(char: string | undefined) {\n    return (\n      char !== undefined &&\n      char.length === 1 &&\n      \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\".indexOf(char) > -1\n    );\n  }\n\n  function scanIdentifierOrKeyword(): Token {\n    saveLocation();\n    // We expect that initial symbol is letter\n    while (isDigit(current()) || isLetter(current())) {\n      incPos();\n    }\n    const value = sliceFromSavedPoint();\n    if (value.length === 0) {\n      throwError(\"Unexpected state\");\n    }\n    const keyword = KEYWORDS.find((x) => x === value);\n    if (keyword) {\n      return {\n        type: keyword,\n        ...savedLocation(),\n      };\n    } else {\n      return {\n        type: \"identifier\",\n        ...savedLocation(),\n        text: value,\n      };\n    }\n  }\n\n  function scanNumber(): Token {\n    saveLocation();\n\n    if (current() === \"0\" && next() === \"x\") {\n      // Hex value\n      incPos(2);\n      while (isHexDigit(current())) {\n        incPos();\n      }\n      const value = sliceFromSavedPoint().slice(2);\n      return {\n        type: \"const-expression\",\n        ...savedLocation(),\n        subtype: \"int\",\n        value: parseInt(value, 16),\n      };\n    }\n\n    if (current() === \"0\" && next() === \"b\") {\n      // Binary value\n      // Not in C99 standart!\n      incPos(2);\n      while (current() === \"0\" || current() === \"1\") {\n        incPos();\n      }\n      const value = sliceFromSavedPoint().slice(2);\n      return {\n        type: \"const-expression\",\n        ...savedLocation(),\n        subtype: \"int\",\n        value: parseInt(value, 2),\n      };\n    }\n\n    let dotSeen = false;\n    while (true) {\n      if (current() === \".\") {\n        if (!dotSeen) {\n          dotSeen = true;\n          incPos();\n        } else {\n          break;\n        }\n      } else if (isDigit(current())) {\n        incPos();\n      } else {\n        break;\n      }\n    }\n    const value = sliceFromSavedPoint();\n    if (dotSeen) {\n      return {\n        type: \"const-expression\",\n        ...savedLocation(),\n        subtype: \"float\",\n        value: parseFloat(value),\n      };\n    } else {\n      return {\n        type: \"const-expression\",\n        ...savedLocation(),\n        subtype: \"int\",\n        value: parseInt(value),\n      };\n    }\n  }\n\n  function scanChar(): Token {\n    saveLocation();\n    incPos();\n    const char = current();\n    if (!char) {\n      throwError(\"Failed to parse char, no char\");\n    }\n    incPos();\n    if (current() !== \"'\") {\n      throwError(\"Failed to parse char, expecting closing '\");\n    }\n    incPos();\n    return {\n      type: \"const-expression\",\n      ...savedLocation(),\n      subtype: \"char\",\n      value: char.charCodeAt(0),\n    };\n  }\n\n  function scanString(): Token {\n    saveLocation();\n    incPos();\n    while (current() !== '\"') {\n      incPos();\n    }\n    incPos();\n    const value = sliceFromSavedPoint().slice(1, -1);\n    return {\n      type: \"string-literal\",\n      ...savedLocation(),\n      value,\n    };\n  }\n\n  function scanOperatorOrPunc(): Token | null {\n    saveLocation();\n\n    if (current() === \".\" && lookAhead(1) === \".\" && lookAhead(2) === \".\") {\n      // Ellipsis is a special case,\n      incPos(3);\n      return {\n        type: \"...\",\n        ...savedLocation(),\n      };\n    }\n\n    // Oh-la-la! Complicated and tricky! Refactor me!\n    let currentOpOrPuncPos = 0;\n    let opOrPuncCandidates = [...PUNCTUATORS].filter((x) => x !== \"...\");\n    while (true) {\n      const lastRoundCandidates = [...opOrPuncCandidates];\n      opOrPuncCandidates = opOrPuncCandidates.filter(\n        (op) =>\n          op[currentOpOrPuncPos] &&\n          op[currentOpOrPuncPos] === lookAhead(currentOpOrPuncPos)\n      );\n      if (opOrPuncCandidates.length === 0) {\n        if (currentOpOrPuncPos > 0) {\n          // we must have lastRoundCandidates\n          if (lastRoundCandidates.length === 0) {\n            throwError(\"Internal error 1\");\n          } else {\n            const lastRoundExactLengthCandidates = lastRoundCandidates.filter(\n              (op) => op.length === currentOpOrPuncPos\n            );\n            if (lastRoundExactLengthCandidates.length === 1) {\n              incPos(currentOpOrPuncPos);\n              if (sliceFromSavedPoint() !== lastRoundExactLengthCandidates[0]) {\n                throwError(\"Internal error 2\");\n              }\n              return {\n                type: lastRoundExactLengthCandidates[0],\n                ...savedLocation(),\n              };\n            }\n          }\n        }\n        return null;\n      }\n\n      if (opOrPuncCandidates.length === 1) {\n        incPos(currentOpOrPuncPos + 1);\n        if (sliceFromSavedPoint() !== opOrPuncCandidates[0]) {\n          console.warn(sliceFromSavedPoint(), opOrPuncCandidates);\n          throwError(\"Internal error 3\");\n        }\n        return {\n          type: opOrPuncCandidates[0],\n          ...savedLocation(),\n        };\n      }\n\n      currentOpOrPuncPos++;\n    }\n  }\n\n  function scan(): Token {\n    scanWhitespace();\n\n    if (pos >= end) {\n      return {\n        type: \"end\",\n        ...savedLocation(),\n      };\n    }\n\n    if (isLetter(current())) {\n      return scanIdentifierOrKeyword();\n    }\n\n    if (isDigit(current())) {\n      return scanNumber();\n    }\n\n    if (current() === \"'\") {\n      return scanChar();\n    }\n    if (current() === '\"') {\n      return scanString();\n    }\n\n    const possibleOpOrPunc = scanOperatorOrPunc();\n    if (possibleOpOrPunc) {\n      return possibleOpOrPunc;\n    }\n\n    throwError(\"Unknown symbols\");\n  }\n\n  return scan;\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar clone_1 = createCommonjsModule(function (module) {\n  var clone = function () {\n    /**\n     * Clones (copies) an Object using deep copying.\n     *\n     * This function supports circular references by default, but if you are certain\n     * there are no circular references in your object, you can save some CPU time\n     * by calling clone(obj, false).\n     *\n     * Caution: if `circular` is false and `parent` contains circular references,\n     * your program may enter an infinite loop and crash.\n     *\n     * @param `parent` - the object to be cloned\n     * @param `circular` - set to true if the object to be cloned may contain\n     *    circular references. (optional - true by default)\n     * @param `depth` - set to a number if the object is only to be cloned to\n     *    a particular depth. (optional - defaults to Infinity)\n     * @param `prototype` - sets the prototype to be used when cloning an object.\n     *    (optional - defaults to parent prototype).\n    */\n\n    function clone(parent, circular, depth, prototype) {\n      var filter;\n\n      if (_typeof(circular) === 'object') {\n        depth = circular.depth;\n        prototype = circular.prototype;\n        filter = circular.filter;\n        circular = circular.circular;\n      } // maintain two arrays for circular references, where corresponding parents\n      // and children have the same index\n\n\n      var allParents = [];\n      var allChildren = [];\n      var useBuffer = typeof Buffer != 'undefined';\n      if (typeof circular == 'undefined') circular = true;\n      if (typeof depth == 'undefined') depth = Infinity; // recurse this function so we don't reset allParents and allChildren\n\n      function _clone(parent, depth) {\n        // cloning null always returns null\n        if (parent === null) return null;\n        if (depth == 0) return parent;\n        var child;\n        var proto;\n\n        if (_typeof(parent) != 'object') {\n          return parent;\n        }\n\n        if (clone.__isArray(parent)) {\n          child = [];\n        } else if (clone.__isRegExp(parent)) {\n          child = new RegExp(parent.source, __getRegExpFlags(parent));\n          if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n        } else if (clone.__isDate(parent)) {\n          child = new Date(parent.getTime());\n        } else if (useBuffer && Buffer.isBuffer(parent)) {\n          if (Buffer.allocUnsafe) {\n            // Node.js >= 4.5.0\n            child = Buffer.allocUnsafe(parent.length);\n          } else {\n            // Older Node.js versions\n            child = new Buffer(parent.length);\n          }\n\n          parent.copy(child);\n          return child;\n        } else {\n          if (typeof prototype == 'undefined') {\n            proto = Object.getPrototypeOf(parent);\n            child = Object.create(proto);\n          } else {\n            child = Object.create(prototype);\n            proto = prototype;\n          }\n        }\n\n        if (circular) {\n          var index = allParents.indexOf(parent);\n\n          if (index != -1) {\n            return allChildren[index];\n          }\n\n          allParents.push(parent);\n          allChildren.push(child);\n        }\n\n        for (var i in parent) {\n          var attrs;\n\n          if (proto) {\n            attrs = Object.getOwnPropertyDescriptor(proto, i);\n          }\n\n          if (attrs && attrs.set == null) {\n            continue;\n          }\n\n          child[i] = _clone(parent[i], depth - 1);\n        }\n\n        return child;\n      }\n\n      return _clone(parent, depth);\n    }\n    /**\n     * Simple flat clone using prototype, accepts only objects, usefull for property\n     * override on FLAT configuration object (no nested props).\n     *\n     * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n     * works.\n     */\n\n\n    clone.clonePrototype = function clonePrototype(parent) {\n      if (parent === null) return null;\n\n      var c = function c() {};\n\n      c.prototype = parent;\n      return new c();\n    }; // private utility functions\n\n\n    function __objToStr(o) {\n      return Object.prototype.toString.call(o);\n    }\n    clone.__objToStr = __objToStr;\n\n    function __isDate(o) {\n      return _typeof(o) === 'object' && __objToStr(o) === '[object Date]';\n    }\n    clone.__isDate = __isDate;\n\n    function __isArray(o) {\n      return _typeof(o) === 'object' && __objToStr(o) === '[object Array]';\n    }\n    clone.__isArray = __isArray;\n\n    function __isRegExp(o) {\n      return _typeof(o) === 'object' && __objToStr(o) === '[object RegExp]';\n    }\n    clone.__isRegExp = __isRegExp;\n\n    function __getRegExpFlags(re) {\n      var flags = '';\n      if (re.global) flags += 'g';\n      if (re.ignoreCase) flags += 'i';\n      if (re.multiline) flags += 'm';\n      return flags;\n    }\n    clone.__getRegExpFlags = __getRegExpFlags;\n    return clone;\n  }();\n\n  if (module.exports) {\n    module.exports = clone;\n  }\n});\n\nvar defaults = function defaults(options, _defaults) {\n  options = options || {};\n  Object.keys(_defaults).forEach(function (key) {\n    if (typeof options[key] === 'undefined') {\n      options[key] = clone_1(_defaults[key]);\n    }\n  });\n  return options;\n};\n\nvar combining = [[0x0300, 0x036F], [0x0483, 0x0486], [0x0488, 0x0489], [0x0591, 0x05BD], [0x05BF, 0x05BF], [0x05C1, 0x05C2], [0x05C4, 0x05C5], [0x05C7, 0x05C7], [0x0600, 0x0603], [0x0610, 0x0615], [0x064B, 0x065E], [0x0670, 0x0670], [0x06D6, 0x06E4], [0x06E7, 0x06E8], [0x06EA, 0x06ED], [0x070F, 0x070F], [0x0711, 0x0711], [0x0730, 0x074A], [0x07A6, 0x07B0], [0x07EB, 0x07F3], [0x0901, 0x0902], [0x093C, 0x093C], [0x0941, 0x0948], [0x094D, 0x094D], [0x0951, 0x0954], [0x0962, 0x0963], [0x0981, 0x0981], [0x09BC, 0x09BC], [0x09C1, 0x09C4], [0x09CD, 0x09CD], [0x09E2, 0x09E3], [0x0A01, 0x0A02], [0x0A3C, 0x0A3C], [0x0A41, 0x0A42], [0x0A47, 0x0A48], [0x0A4B, 0x0A4D], [0x0A70, 0x0A71], [0x0A81, 0x0A82], [0x0ABC, 0x0ABC], [0x0AC1, 0x0AC5], [0x0AC7, 0x0AC8], [0x0ACD, 0x0ACD], [0x0AE2, 0x0AE3], [0x0B01, 0x0B01], [0x0B3C, 0x0B3C], [0x0B3F, 0x0B3F], [0x0B41, 0x0B43], [0x0B4D, 0x0B4D], [0x0B56, 0x0B56], [0x0B82, 0x0B82], [0x0BC0, 0x0BC0], [0x0BCD, 0x0BCD], [0x0C3E, 0x0C40], [0x0C46, 0x0C48], [0x0C4A, 0x0C4D], [0x0C55, 0x0C56], [0x0CBC, 0x0CBC], [0x0CBF, 0x0CBF], [0x0CC6, 0x0CC6], [0x0CCC, 0x0CCD], [0x0CE2, 0x0CE3], [0x0D41, 0x0D43], [0x0D4D, 0x0D4D], [0x0DCA, 0x0DCA], [0x0DD2, 0x0DD4], [0x0DD6, 0x0DD6], [0x0E31, 0x0E31], [0x0E34, 0x0E3A], [0x0E47, 0x0E4E], [0x0EB1, 0x0EB1], [0x0EB4, 0x0EB9], [0x0EBB, 0x0EBC], [0x0EC8, 0x0ECD], [0x0F18, 0x0F19], [0x0F35, 0x0F35], [0x0F37, 0x0F37], [0x0F39, 0x0F39], [0x0F71, 0x0F7E], [0x0F80, 0x0F84], [0x0F86, 0x0F87], [0x0F90, 0x0F97], [0x0F99, 0x0FBC], [0x0FC6, 0x0FC6], [0x102D, 0x1030], [0x1032, 0x1032], [0x1036, 0x1037], [0x1039, 0x1039], [0x1058, 0x1059], [0x1160, 0x11FF], [0x135F, 0x135F], [0x1712, 0x1714], [0x1732, 0x1734], [0x1752, 0x1753], [0x1772, 0x1773], [0x17B4, 0x17B5], [0x17B7, 0x17BD], [0x17C6, 0x17C6], [0x17C9, 0x17D3], [0x17DD, 0x17DD], [0x180B, 0x180D], [0x18A9, 0x18A9], [0x1920, 0x1922], [0x1927, 0x1928], [0x1932, 0x1932], [0x1939, 0x193B], [0x1A17, 0x1A18], [0x1B00, 0x1B03], [0x1B34, 0x1B34], [0x1B36, 0x1B3A], [0x1B3C, 0x1B3C], [0x1B42, 0x1B42], [0x1B6B, 0x1B73], [0x1DC0, 0x1DCA], [0x1DFE, 0x1DFF], [0x200B, 0x200F], [0x202A, 0x202E], [0x2060, 0x2063], [0x206A, 0x206F], [0x20D0, 0x20EF], [0x302A, 0x302F], [0x3099, 0x309A], [0xA806, 0xA806], [0xA80B, 0xA80B], [0xA825, 0xA826], [0xFB1E, 0xFB1E], [0xFE00, 0xFE0F], [0xFE20, 0xFE23], [0xFEFF, 0xFEFF], [0xFFF9, 0xFFFB], [0x10A01, 0x10A03], [0x10A05, 0x10A06], [0x10A0C, 0x10A0F], [0x10A38, 0x10A3A], [0x10A3F, 0x10A3F], [0x1D167, 0x1D169], [0x1D173, 0x1D182], [0x1D185, 0x1D18B], [0x1D1AA, 0x1D1AD], [0x1D242, 0x1D244], [0xE0001, 0xE0001], [0xE0020, 0xE007F], [0xE0100, 0xE01EF]];\n\nvar DEFAULTS = {\n  nul: 0,\n  control: 0\n};\n\nvar config = function config(opts) {\n  opts = defaults(opts || {}, DEFAULTS);\n  return function wcwidth(str) {\n    return wcswidth(str, opts);\n  };\n};\n/*\n *  The following functions define the column width of an ISO 10646\n *  character as follows:\n *  - The null character (U+0000) has a column width of 0.\n *  - Other C0/C1 control characters and DEL will lead to a return value\n *    of -1.\n *  - Non-spacing and enclosing combining characters (general category\n *    code Mn or Me in the\n *    Unicode database) have a column width of 0.\n *  - SOFT HYPHEN (U+00AD) has a column width of 1.\n *  - Other format characters (general category code Cf in the Unicode\n *    database) and ZERO WIDTH\n *    SPACE (U+200B) have a column width of 0.\n *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)\n *    have a column width of 0.\n *  - Spacing characters in the East Asian Wide (W) or East Asian\n *    Full-width (F) category as\n *    defined in Unicode Technical Report #11 have a column width of 2.\n *  - All remaining characters (including all printable ISO 8859-1 and\n *    WGL4 characters, Unicode control characters, etc.) have a column\n *    width of 1.\n *  This implementation assumes that characters are encoded in ISO 10646.\n*/\n\n\nfunction wcswidth(str, opts) {\n  if (typeof str !== 'string') return wcwidth(str, opts);\n  var s = 0;\n\n  for (var i = 0; i < str.length; i++) {\n    var n = wcwidth(str.charCodeAt(i), opts);\n    if (n < 0) return -1;\n    s += n;\n  }\n\n  return s;\n}\n\nfunction wcwidth(ucs, opts) {\n  // test for 8-bit control characters\n  if (ucs === 0) return opts.nul;\n  if (ucs < 32 || ucs >= 0x7f && ucs < 0xa0) return opts.control; // binary search in table of non-spacing characters\n\n  if (bisearch(ucs)) return 0; // if we arrive here, ucs is not a combining or C0/C1 control character\n\n  return 1 + (ucs >= 0x1100 && (ucs <= 0x115f || // Hangul Jamo init. consonants\n  ucs == 0x2329 || ucs == 0x232a || ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f || // CJK ... Yi\n  ucs >= 0xac00 && ucs <= 0xd7a3 || // Hangul Syllables\n  ucs >= 0xf900 && ucs <= 0xfaff || // CJK Compatibility Ideographs\n  ucs >= 0xfe10 && ucs <= 0xfe19 || // Vertical forms\n  ucs >= 0xfe30 && ucs <= 0xfe6f || // CJK Compatibility Forms\n  ucs >= 0xff00 && ucs <= 0xff60 || // Fullwidth Forms\n  ucs >= 0xffe0 && ucs <= 0xffe6 || ucs >= 0x20000 && ucs <= 0x2fffd || ucs >= 0x30000 && ucs <= 0x3fffd));\n}\n\nfunction bisearch(ucs) {\n  var min = 0;\n  var max = combining.length - 1;\n  var mid;\n  if (ucs < combining[0][0] || ucs > combining[max][1]) return false;\n\n  while (max >= min) {\n    mid = Math.floor((min + max) / 2);\n    if (ucs > combining[mid][1]) min = mid + 1;else if (ucs < combining[mid][0]) max = mid - 1;else return true;\n  }\n\n  return false;\n}\n\n// Generated by CoffeeScript 2.4.1\nvar _pad;\n\n_pad = function pad(text, length, options) {\n  var escapecolor, invert, padlength, textnocolors;\n\n  if (options == null) {\n    options = {};\n  }\n\n  invert = typeof text === 'number';\n\n  if (invert) {\n    var _ref = [text, length];\n    length = _ref[0];\n    text = _ref[1];\n  }\n\n  if (typeof options === 'string') {\n    options = {\n      \"char\": options\n    };\n  }\n\n  if (options[\"char\"] == null) {\n    options[\"char\"] = ' ';\n  }\n\n  if (options.strip == null) {\n    options.strip = false;\n  }\n\n  if (typeof text !== 'string') {\n    text = text.toString();\n  }\n\n  textnocolors = null;\n  _pad = '';\n\n  if (options.colors) {\n    escapecolor = /\\x1B\\[(?:[0-9]{1,2}(?:;[0-9]{1,2})?)?[m|K]/g;\n    textnocolors = text.replace(escapecolor, '');\n  }\n\n  padlength = options.fixed_width ? length - (textnocolors || text).length : length - config(options.wcwidth_options)(textnocolors || text);\n\n  if (padlength < 0) {\n    if (options.strip) {\n      if (invert) {\n        return text.substr(length * -1);\n      } else {\n        return text.substr(0, length);\n      }\n    }\n\n    return text;\n  }\n\n  _pad += options[\"char\"].repeat(padlength);\n\n  if (invert) {\n    return _pad + text;\n  } else {\n    return text + _pad;\n  }\n};\n\nvar _pad$1 = _pad;\n\nexport default _pad$1;\n","import {\n  IdentifierNode,\n  Typename,\n  DeclaratorNode,\n  NodeLocator,\n  DeclaratorMap,\n  DeclaratorId,\n} from \"./parser.definitions\";\nimport pad from \"pad\";\n\nimport { SymbolTableError } from \"./error\";\n\nexport type IdentifierToTypename = Map<IdentifierNode, DeclaratorNode>;\n\nexport class SymbolTable {\n  constructor(private readonly locator: NodeLocator) {\n    // nothing here\n  }\n\n  /** List of declarations for whole compilaion unit */\n  private readonly translationUnitDeclarations: DeclaratorId[] = [];\n  /** List of declarations inside current function scope */\n  private autoInFunctionDeclarations: DeclaratorId[] | null = null;\n\n  private readonly declarations: DeclaratorNode[][] = [];\n\n  enterScope() {\n    this.declarations.push([]);\n  }\n\n  enterFunctionScope() {\n    this.enterScope();\n\n    if (this.autoInFunctionDeclarations !== null) {\n      throw new Error(\"Internal error: already in function scope\");\n    }\n    this.autoInFunctionDeclarations = [];\n  }\n\n  addEntry(declaration: DeclaratorNode) {\n    const currentScope = this.declarations[this.declarations.length - 1];\n    if (\n      currentScope.find(\n        (declarationInCurrentScope) =>\n          declarationInCurrentScope.identifier === declaration.identifier\n      )\n    ) {\n      const declaratorLocation = this.locator.get(declaration);\n      if (!declaratorLocation) {\n        throw new Error(\n          `Duplicate declaration ${declaration.identifier} and not able to find location for previous declaration`\n        );\n      }\n\n      throw new SymbolTableError(\n        `Duplicate declaration ${declaration.identifier}`,\n        declaratorLocation\n      );\n    }\n    currentScope.push(declaration);\n\n    if (\n      declaration.storageSpecifier === \"extern\" ||\n      declaration.storageSpecifier === \"static\" ||\n      !this.autoInFunctionDeclarations\n    ) {\n      this.translationUnitDeclarations.push(declaration.declaratorId);\n    } else {\n      this.autoInFunctionDeclarations.push(declaration.declaratorId);\n    }\n\n    this.declaratorIdToDeclaratorMap.set(declaration.declaratorId, declaration);\n  }\n\n  /** Call me when parsing is complete */\n  getTranslationUnittDeclarations() {\n    return this.translationUnitDeclarations;\n  }\n\n  leaveScope(): void {\n    const currentScope = this.declarations.pop();\n    if (!currentScope) {\n      throw new Error(\"Unable to leave scope, no scope at all\");\n    }\n  }\n\n  leaveFunctionScope() {\n    const currentScope = this.declarations.pop();\n    if (!currentScope) {\n      throw new Error(\"Unable to leave scope, no scope at all\");\n    }\n    const declaredInFunction = this.autoInFunctionDeclarations;\n    this.autoInFunctionDeclarations = null;\n    if (declaredInFunction === null) {\n      throw new Error(\n        \"Internal error: unable to leave function scope because did no enter there\"\n      );\n    }\n    return declaredInFunction;\n  }\n\n  /*\n   * ???? Remove this\n   \n  getCurrentScopeDeclarations() {\n    const currentScope = this.declarations[this.declarations.length - 1];\n    if (!currentScope) {\n      throw new Error(\"No current scope\");\n    }\n    return currentScope;\n  }\n  */\n\n  lookupInScopes(identifier: string): DeclaratorNode | undefined {\n    for (const scope of this.declarations.slice().reverse()) {\n      for (const declaration of scope) {\n        if (declaration.identifier === identifier) {\n          return declaration;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  isIdentifierAlreadyDefinedInCurrentScope(identifier: string) {\n    const currentScope = this.declarations.slice().pop();\n    if (!currentScope) {\n      throw new Error(\"No current scope!\");\n    }\n    for (const declaration of currentScope) {\n      if (declaration.identifier === identifier) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private currentGlobalId = 1;\n  createDeclaratorId() {\n    let id = pad(4, `${this.currentGlobalId.toString(16).toUpperCase()}`, \"0\");\n    this.currentGlobalId++;\n    return id as DeclaratorId;\n  }\n\n  private readonly declaratorIdToDeclaratorMap: DeclaratorMap = new Map();\n  /** Call me when parsing is complete */\n  public getDeclaratorsMap() {\n    return this.declaratorIdToDeclaratorMap;\n  }\n}\n","import {\n  BinaryOperator,\n  TypeSignedUnsigned,\n  AssignmentOperator,\n  StorageClass,\n} from \"./scanner.func\";\nimport { TokenLocation } from \"./error\";\n\n//\n// ============= Expressions =============\n//\nexport type DeclaratorId = string & { readonly _nominal: \"declarator id \" };\n\nexport type IdentifierNode = {\n  type: \"identifier\";\n  value: string;\n  declaratorNodeId: DeclaratorId;\n};\n\nexport type PrimaryExpressionNode =\n  | IdentifierNode\n  | {\n      type: \"const\";\n      subtype: \"int\" | \"float\" | \"char\";\n      value: number;\n    }\n  | {\n      type: \"string-literal\";\n      value: string;\n    };\n\nexport type PostfixExpressionNode =\n  | PrimaryExpressionNode\n  | {\n      type: \"subscript operator\";\n      target: ExpressionNode;\n      index: ExpressionNode;\n    }\n  | {\n      type: \"function call\";\n      target: ExpressionNode;\n      args: ArgumentExpressionList;\n    }\n  | {\n      type: \"struct access\";\n      target: ExpressionNode;\n      identifier: string;\n    }\n  | {\n      type: \"struct pointer access\";\n      target: ExpressionNode;\n      identifier: string;\n    }\n  | {\n      type: \"postfix ++\";\n      target: ExpressionNode;\n    }\n  | {\n      type: \"postfix --\";\n      target: ExpressionNode;\n    };\n\n// @TODO PostfixExpressionNode:   ( type-name ) { initializer-list }\n// @TODO PostfixExpressionNode: ( type-name ) { initializer-list , }\n\nexport const UNARY_OPERATORS = [\"&\", \"*\", \"+\", \"-\", \"~\", \"!\"] as const;\nexport type UnaryOperator = typeof UNARY_OPERATORS[number];\n\nexport type UnaryExpressionNode =\n  | PostfixExpressionNode\n  | {\n      type: \"prefix --\";\n      target: ExpressionNode;\n    }\n  | {\n      type: \"prefix ++\";\n      target: ExpressionNode;\n    }\n  | {\n      type: \"unary-operator\";\n      operator: UnaryOperator;\n      target: ExpressionNode;\n    }\n  | {\n      type: \"sizeof expression\";\n      expression: ExpressionNode;\n    }\n  | {\n      type: \"sizeof typename\";\n      typename: Typename;\n    };\n\nexport type CastExpressionNode =\n  | UnaryExpressionNode\n  | {\n      type: \"cast\";\n      typename: Typename;\n      target: ExpressionNode;\n    };\n\nexport type BinaryOperatorNode =\n  | CastExpressionNode\n  | {\n      type: \"binary operator\";\n      operator: BinaryOperator;\n      left: ExpressionNode;\n      right: ExpressionNode;\n    };\n\nexport type ConditionalExpressionNode =\n  | BinaryOperatorNode\n  | {\n      type: \"conditional expression\";\n      condition: ExpressionNode;\n      iftrue: ExpressionNode;\n      iffalse: ExpressionNode;\n    };\n\nexport type ArgumentExpressionList = ExpressionNode[];\n\ninterface AssignmentExpression {\n  type: \"assignment\";\n  operator: AssignmentOperator;\n  lvalue: ExpressionNode;\n  rvalue: ExpressionNode;\n}\nexport type AssignmentExpressionNode =\n  | ConditionalExpressionNode\n  | AssignmentExpression;\n\nexport type ExpressionNode =\n  | AssignmentExpressionNode\n  | {\n      type: \"expression with sideeffect\";\n      sizeeffect: ExpressionNode;\n      effectiveValue: ExpressionNode;\n    };\n\n//\n// ============= Types =============\n//\n\nexport type ArithmeticType =\n  | \"char\"\n  | \"short\"\n  | \"int\"\n  | \"long long\"\n  | \"float\"\n  | \"double\";\n\nexport type FunctionTypename = {\n  type: \"function\";\n  parameters: (DeclaratorNode | Typename)[];\n  haveEndingEllipsis: boolean;\n  returnType: Typename;\n  const: true;\n};\n\nexport type TypenameArithmetic = {\n  type: \"arithmetic\";\n  arithmeticType: ArithmeticType;\n  signedUnsigned: TypeSignedUnsigned | null;\n  const: boolean;\n};\n\nexport type TypenamePointer = {\n  type: \"pointer\";\n  const: boolean;\n  pointsTo: Typename;\n};\n\nexport type TypenameScalar = TypenameArithmetic | TypenamePointer;\n\nexport type Typename =\n  | TypenameScalar\n  | { type: \"void\"; const: boolean }\n  | {\n      type: \"struct\";\n      const: boolean;\n      // @TODO\n    }\n  | {\n      type: \"enum\";\n      const: boolean;\n      // @TODO\n    }\n  | {\n      type: \"array\";\n      elementsTypename: Typename;\n      size: ExpressionNode | \"*\" | null;\n      const: true;\n    }\n  | FunctionTypename\n  | {\n      type: \"function-knr\";\n      parametersIdentifiers: IdentifierNode[];\n      returnType: Typename;\n      const: true;\n    };\n\ntype DeclaratorNodeGeneric<T extends Typename> = {\n  type: \"declarator\";\n  identifier: string;\n  typename: T;\n  storageSpecifier: StorageClass | null;\n  functionSpecifier: \"inline\" | null;\n\n  declaratorId: DeclaratorId;\n\n  initializer?: T extends FunctionTypename ? null : InitializerNode;\n\n  /**\n   * Not in use for \"register\" and \"typedef\" storage\n   */\n  memoryOffset?: number;\n  memoryIsGlobal?: boolean;\n};\n\n/**\n * Proper name for this should be \"parameter-declaration\"\n * Because it consists of only one declaration and have no initializer\n */\nexport type DeclaratorNode = DeclaratorNodeGeneric<Typename>;\nexport type DeclaratorNodeFunction = DeclaratorNodeGeneric<FunctionTypename>;\n\nexport type Node =\n  | ExpressionNode\n  | Typename\n  | DeclaratorNode\n  | FunctionDefinition\n  | CompoundStatement\n  | CompoundStatementBody\n  | InitializerNode;\nexport type NodeLocator = Map<Node, TokenLocation>;\n\nexport interface IfStatement {\n  type: \"if\";\n  condition: ExpressionNode;\n  iftrue: Statement;\n  iffalse?: Statement;\n}\n\nexport interface WhileStatement {\n  type: \"while\";\n  condition: ExpressionNode;\n  body: Statement;\n}\n\nexport interface DoWhileStatement {\n  type: \"dowhile\";\n  condition: ExpressionNode;\n  body: Statement;\n}\nexport interface ContinueStatement {\n  type: \"continue\";\n}\nexport interface BreakStatement {\n  type: \"break\";\n}\nexport interface ReturnStatement {\n  type: \"return\";\n  expression?: ExpressionNode;\n}\n\nexport interface ExpressionStatement {\n  type: \"expression\";\n  expression: ExpressionNode;\n}\n\nexport interface EmpryExpressionStatement {\n  type: \"noop\";\n}\n\nexport type Statement =\n  | IfStatement\n  | WhileStatement\n  | DoWhileStatement\n  | ContinueStatement\n  | BreakStatement\n  | ReturnStatement\n  | CompoundStatement\n  | ExpressionStatement\n  | EmpryExpressionStatement;\n\nexport type InitializerNode =\n  | {\n      type: \"assigmnent-expression\";\n      expression: ExpressionNode;\n    }\n  | {\n      type: \"initializer-list\";\n      // TODO\n    };\n\nexport type CompoundStatementBody = Statement | DeclaratorNode;\n\nexport type CompoundStatement = {\n  type: \"compound-statement\";\n  body: CompoundStatementBody[];\n};\n\nexport type FunctionDefinition = {\n  type: \"function-declaration\";\n  declaration: DeclaratorNodeFunction;\n  body: CompoundStatementBody[];\n  declaredVariables: DeclaratorId[];\n};\n\nexport type ExternalDeclarations = (FunctionDefinition | DeclaratorNode)[];\n\nexport type DeclaratorMap = Map<DeclaratorId, DeclaratorNode>;\n\nexport type TranslationUnit = {\n  type: \"translation-unit\";\n  body: ExternalDeclarations;\n  declarations: DeclaratorId[];\n  /**\n   *  A function here to support JSON.stringify\n   *  If deserialized, then map should be recalculated\n   */\n  declaratorMap: () => DeclaratorMap;\n\n  /** Same reasons as declaratorMap.\n   *  Maybe every node should have own \"location\" property\n   */\n  locationMap: () => NodeLocator;\n};\n","import { Scanner } from \"./scanner\";\nimport {\n  TYPE_SPECIFIERS_ARITHMETIC,\n  Punctuator,\n  BinaryOperator,\n  Token,\n  ASSIGNMENT_OPERATORS,\n} from \"./scanner.func\";\nimport {\n  ExpressionNode,\n  PostfixExpressionNode,\n  AssignmentExpressionNode,\n  UNARY_OPERATORS,\n  Typename,\n  NodeLocator,\n  IdentifierNode,\n} from \"./parser.definitions\";\nimport { ParserError } from \"./error\";\nimport { SymbolTable } from \"./parser.symboltable\";\n\nconst MAX_BINARY_OP_INDEX = 10;\n\nfunction isTokenBinaryOperatorAtPrioLevel(\n  prioLevel: number,\n  token: Token\n): BinaryOperator | undefined {\n  function check(...binaryOps: BinaryOperator[]): BinaryOperator | undefined {\n    const binaryOp = binaryOps.find((x) => x === token.type);\n    return binaryOp;\n  }\n  switch (prioLevel) {\n    case 1:\n      return check(\"*\", \"/\", \"%\");\n    case 2:\n      return check(\"+\", \"-\");\n    case 3:\n      return check(\"<<\", \">>\");\n    case 4:\n      return check(\"<\", \">\", \"<=\", \">=\");\n    case 5:\n      return check(\"==\", \"!=\");\n    case 6:\n      return check(\"&\");\n    case 7:\n      return check(\"^\");\n    case 8:\n      return check(\"|\");\n    case 9:\n      return check(\"&&\");\n    case 10:\n      return check(\"||\");\n    default:\n      throw new Error(`Unknown prio level`);\n  }\n}\n\nexport interface ExpressionRequirements {\n  isCurrentTokenLooksLikeTypeName(): boolean;\n  readTypeName(): Typename;\n}\n\nexport function createExpressionParser(\n  scanner: Scanner,\n  locator: NodeLocator,\n  typeParser: ExpressionRequirements,\n  symbolTable: SymbolTable\n) {\n  function throwError(info: string): never {\n    throw new ParserError(`${info}`, scanner.current());\n  }\n\n  function readPrimaryExpression(): ExpressionNode {\n    const token = scanner.current();\n    if (token.type === \"identifier\") {\n      scanner.readNext();\n\n      const identifierDeclaration = symbolTable.lookupInScopes(token.text);\n      if (!identifierDeclaration) {\n        throwError(`Unable to find declaration for '${token.text}'`);\n      }\n      const node: IdentifierNode = {\n        type: \"identifier\",\n        value: token.text,\n        declaratorNodeId: identifierDeclaration.declaratorId,\n      };\n\n      locator.set(node, token);\n\n      return node;\n    } else if (token.type === \"const-expression\") {\n      scanner.readNext();\n      const node: ExpressionNode = {\n        type: \"const\",\n        subtype: token.subtype,\n        value: token.value,\n      };\n      locator.set(node, token);\n      return node;\n    } else if (token.type === \"string-literal\") {\n      scanner.readNext();\n      const node: ExpressionNode = {\n        type: \"string-literal\",\n        value: token.value,\n      };\n      locator.set(node, token);\n      return node;\n    } else if (token.type === \"(\") {\n      scanner.readNext();\n      const expression = readExpression();\n      const closing = scanner.current();\n      if (closing.type !== \")\") {\n        throwError(\"Expecting closing brace\");\n      }\n      scanner.readNext();\n      locator.set(expression, {\n        ...token,\n        length: closing.pos - token.pos + closing.length,\n      });\n      return expression;\n    } else {\n      throwError(\"Expecting primary-expression\");\n    }\n  }\n\n  function readPostfixExpression(): ExpressionNode {\n    let left: ExpressionNode = readPrimaryExpression();\n\n    while (true) {\n      const token = scanner.current();\n      if (token.type === \"[\") {\n        scanner.readNext();\n        const expression = readExpression();\n\n        const closing = scanner.current();\n        if (closing.type !== \"]\") {\n          throwError(\"Expected ]\");\n        }\n        scanner.readNext();\n        const newLeft: PostfixExpressionNode = {\n          type: \"subscript operator\",\n          target: left,\n          index: expression,\n        };\n        locator.set(newLeft, {\n          ...token,\n          length: closing.pos - token.pos + closing.length,\n        });\n        left = newLeft;\n      } else if (token.type === \"(\") {\n        scanner.readNext();\n\n        const args =\n          scanner.current().type !== \")\" ? readArgumentExpressionList() : [];\n\n        const closing = scanner.current();\n        if (closing.type !== \")\") {\n          throwError(\"Postfix-expression expected ) \");\n        }\n        scanner.readNext();\n        const newLeft: PostfixExpressionNode = {\n          type: \"function call\",\n          target: left,\n          args,\n        };\n        locator.set(newLeft, {\n          ...token,\n          length: closing.pos - token.pos + closing.length,\n        });\n        left = newLeft;\n      } else if (token.type === \".\" || token.type === \"->\") {\n        scanner.readNext();\n        const identifierToken = scanner.current();\n        if (identifierToken.type !== \"identifier\") {\n          throwError(\"Expected identifier\");\n        }\n        scanner.readNext();\n        const newLeft: PostfixExpressionNode = {\n          type: token.type === \".\" ? \"struct access\" : \"struct pointer access\",\n          identifier: identifierToken.text,\n          target: left,\n        };\n        locator.set(newLeft, {\n          ...token,\n        });\n\n        left = newLeft;\n      } else if (token.type === \"++\") {\n        scanner.readNext();\n        const newLeft: PostfixExpressionNode = {\n          type: \"postfix ++\",\n          target: left,\n        };\n        locator.set(newLeft, {\n          ...token,\n        });\n        left = newLeft;\n      } else if (token.type === \"--\") {\n        scanner.readNext();\n        const newLeft: PostfixExpressionNode = {\n          type: \"postfix --\",\n          target: left,\n        };\n        locator.set(newLeft, {\n          ...token,\n        });\n        left = newLeft;\n      } else {\n        break;\n      }\n    }\n    return left;\n  }\n\n  function readArgumentExpressionList() {\n    const nodes: ExpressionNode[] = [];\n    while (true) {\n      const node = readAssignmentExpression();\n      nodes.push(node);\n\n      if (scanner.current().type === \",\") {\n        scanner.readNext();\n      } else {\n        break;\n      }\n    }\n    return nodes;\n  }\n\n  function readUnaryExpression(): ExpressionNode {\n    const token = scanner.current();\n\n    const unaryOperator = UNARY_OPERATORS.find((op) => op === token.type);\n\n    if (unaryOperator) {\n      scanner.readNext();\n      const right = readUnaryExpression();\n\n      const node: ExpressionNode = {\n        type: \"unary-operator\",\n        operator: unaryOperator,\n        target: right,\n      };\n      locator.set(node, {\n        ...token,\n      });\n      return node;\n    } else if (token.type === \"++\" || token.type === \"--\") {\n      scanner.readNext();\n      const right = readUnaryExpression();\n\n      const node: ExpressionNode = {\n        type: token.type === \"++\" ? \"prefix ++\" : \"prefix --\",\n        target: right,\n      };\n      locator.set(node, {\n        ...token,\n      });\n      return node;\n    } else if (token.type === \"sizeof\") {\n      scanner.readNext();\n      let node: ExpressionNode;\n\n      if (scanner.current().type === \"(\") {\n        scanner.readNext();\n\n        if (typeParser.isCurrentTokenLooksLikeTypeName()) {\n          const typename = typeParser.readTypeName();\n          if (scanner.current().type !== \")\") {\n            throwError(\"Expected )\");\n          }\n          scanner.readNext();\n          node = {\n            type: \"sizeof typename\",\n            typename: typename,\n          };\n        } else {\n          // Doing the same as in readUnaryExpression\n          // We can pushBack this token and call readUnaryExpression, but\n          //  this does not matter\n          const expressionNode = readExpression();\n\n          if (scanner.current().type !== \")\") {\n            throwError(\"Expected )\");\n          }\n          scanner.readNext();\n\n          node = {\n            type: \"sizeof expression\",\n            expression: expressionNode,\n          };\n        }\n      } else {\n        const unaryExpressionNode = readUnaryExpression();\n\n        node = {\n          type: \"sizeof expression\",\n          expression: unaryExpressionNode,\n        };\n      }\n      locator.set(node, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      return node;\n    } else {\n      const postfixExpression = readPostfixExpression();\n      return postfixExpression;\n    }\n  }\n\n  function readCastExpression(): ExpressionNode {\n    const token = scanner.current();\n\n    if (token.type !== \"(\") {\n      const unaryExpression = readUnaryExpression();\n      return unaryExpression;\n    }\n\n    scanner.readNext();\n\n    if (typeParser.isCurrentTokenLooksLikeTypeName()) {\n      const typename = typeParser.readTypeName();\n      if (scanner.current().type !== \")\") {\n        throwError(\"Expected )\");\n      }\n      scanner.readNext();\n\n      const castTarget = readCastExpression();\n\n      const node: ExpressionNode = {\n        type: \"cast\",\n        typename: typename,\n        target: castTarget,\n      };\n      locator.set(node, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      return node;\n    } else {\n      // This means that \"(\" is not a part of cast-expression, it is a unary-expression\n      scanner.pushBack(token);\n      const unaryExpression = readUnaryExpression();\n      return unaryExpression;\n    }\n  }\n\n  function readLogicalOrExpression(): ExpressionNode {\n    function read(currentPriority: number): ExpressionNode {\n      if (currentPriority === 0) {\n        return readCastExpression();\n      }\n\n      let left = read(currentPriority - 1);\n\n      while (true) {\n        const token = scanner.current();\n\n        const binaryOperator = isTokenBinaryOperatorAtPrioLevel(\n          currentPriority,\n          token\n        );\n\n        if (!binaryOperator) {\n          return left;\n        }\n\n        scanner.readNext();\n        const right = read(currentPriority - 1);\n\n        const newLeft: ExpressionNode = {\n          type: \"binary operator\",\n          operator: binaryOperator,\n          left,\n          right,\n        };\n        locator.set(newLeft, token);\n        left = newLeft;\n      }\n    }\n\n    return read(MAX_BINARY_OP_INDEX);\n  }\n\n  function readConditionalExpression(): ExpressionNode {\n    const startTokenForLocator = scanner.current();\n\n    const condition = readLogicalOrExpression();\n\n    const questionToken = scanner.current();\n    if (questionToken.type === \"?\") {\n      scanner.readNext();\n      const iftrue = readExpression();\n\n      const colonToken = scanner.current();\n      if (colonToken.type !== \":\") {\n        throwError(\"Expecting colon\");\n      }\n      scanner.readNext();\n      const iffalse = readConditionalExpression();\n\n      const node: ExpressionNode = {\n        type: \"conditional expression\",\n        condition,\n        iftrue,\n        iffalse,\n      };\n      locator.set(node, {\n        ...startTokenForLocator,\n        length: scanner.current().pos - startTokenForLocator.pos,\n      });\n      return node;\n    } else {\n      return condition;\n    }\n  }\n\n  function readAssignmentExpression(): ExpressionNode {\n    const conditionExpression = readConditionalExpression();\n\n    const possibleAssignmentOperatorToken = scanner.current();\n    const assignmentOperator = ASSIGNMENT_OPERATORS.find(\n      (op) => possibleAssignmentOperatorToken.type === op\n    );\n    if (!assignmentOperator) {\n      return conditionExpression;\n    }\n\n    // Here we can validate that lvalue expression is actually an lvalue\n    // For example, filter out conditional expressions and so on\n    // But we will do this on next stage\n\n    scanner.readNext();\n\n    const rvalue = readAssignmentExpression();\n\n    const node: ExpressionNode = {\n      type: \"assignment\",\n      operator: assignmentOperator,\n      lvalue: conditionExpression,\n      rvalue: rvalue,\n    };\n    locator.set(node, possibleAssignmentOperatorToken);\n    return node;\n  }\n\n  function readExpression(): ExpressionNode {\n    const tokenForLocator = scanner.current();\n    const left = readAssignmentExpression();\n    if (scanner.current().type === \",\") {\n      scanner.readNext();\n      const effectiveValue = readExpression();\n      const node: ExpressionNode = {\n        type: \"expression with sideeffect\",\n        sizeeffect: left,\n        effectiveValue: effectiveValue,\n      };\n      locator.set(node, {\n        ...tokenForLocator,\n        length: scanner.current().pos - tokenForLocator.pos,\n      });\n      return node;\n    } else {\n      return left;\n    }\n  }\n\n  function readConstantExpression() {\n    return readConditionalExpression();\n  }\n\n  return {\n    readExpression,\n    readAssignmentExpression,\n    readConstantExpression,\n  };\n}\n","import { Scanner } from \"./scanner\";\nimport {\n  TYPE_SPECIFIERS_ARITHMETIC,\n  TypeQualifier,\n  TYPE_QUALIFIERS,\n  TypeSignedUnsigned,\n  StorageClass,\n  STORAGE_CLASSES,\n  TYPE_SPECIFIERS_UNDERSCORE,\n  Token,\n} from \"./scanner.func\";\nimport {\n  Typename,\n  ExpressionNode,\n  NodeLocator,\n  DeclaratorNode,\n  IdentifierNode,\n  FunctionDefinition,\n  DeclaratorNodeFunction,\n  CompoundStatementBody,\n  CompoundStatement,\n  IfStatement,\n  Statement,\n  WhileStatement,\n  ExpressionStatement,\n  EmpryExpressionStatement,\n  DoWhileStatement,\n  ContinueStatement,\n  BreakStatement,\n  ReturnStatement,\n  ExternalDeclarations,\n  InitializerNode,\n} from \"./parser.definitions\";\nimport { ParserError } from \"./error\";\nimport { SymbolTable } from \"./parser.symboltable\";\nimport { createExpressionParser } from \"./parser.expression\";\n\nexport interface TypeParserDependencies {\n  readAssignmentExpression: () => ExpressionNode;\n}\nexport function createParser(\n  scanner: Scanner,\n  locator: NodeLocator,\n  symbolTable: SymbolTable\n) {\n  function throwError(info: string): never {\n    // console.info(info, scanner.current());\n    throw new ParserError(`${info}`, scanner.current());\n  }\n\n  function assertTokenAndReadNext(type: Token[\"type\"]) {\n    if (scanner.current().type !== type) {\n      throwError(`Expected ${type}`);\n    }\n    scanner.readNext();\n  }\n\n  const expressionReader = createExpressionParser(\n    scanner,\n    locator,\n    {\n      // Functions already hoisted\n      isCurrentTokenLooksLikeTypeName: isCurrentTokenLooksLikeTypeName,\n      readTypeName: readTypeName,\n    },\n    symbolTable\n  );\n\n  function isCurrentTokenTypeQualifier() {\n    const token = scanner.current();\n    const qualifier = TYPE_QUALIFIERS.find((x) => token.type === x);\n    return qualifier;\n  }\n\n  function isCurrentTokenTypeVoid() {\n    const token = scanner.current();\n    return token.type === \"void\" ? token.type : undefined;\n  }\n  function isCurrentTokenTypeArithmeticSpecifier() {\n    const token = scanner.current();\n    const arithmeticType = TYPE_SPECIFIERS_ARITHMETIC.find(\n      (x) => x === token.type\n    );\n    return arithmeticType;\n  }\n  function isCurrentTokenTypeUnderscoreSpecifier() {\n    const token = scanner.current();\n    const arithmeticType = TYPE_SPECIFIERS_UNDERSCORE.find(\n      (x) => x === token.type\n    );\n    return arithmeticType;\n  }\n\n  function isCurrentTokenAStorageClassSpecifier() {\n    const token = scanner.current();\n    const storageClassSpecifier = STORAGE_CLASSES.find((x) => x === token.type);\n    return storageClassSpecifier;\n  }\n  function isCurrentTokenAFunctionSpecifier() {\n    const token = scanner.current();\n    return token.type === \"inline\" ? token.type : undefined;\n  }\n\n  function isCurrentTokenTypedefName(): Typename | undefined {\n    const token = scanner.current();\n    if (token.type !== \"identifier\") {\n      return undefined;\n    }\n\n    // This call adds this node into cache, but it is useless thing\n    // We add this type definition directly into type node\n    // Maybe this is wrong\n    const symbolTableEntry = symbolTable.lookupInScopes(token.text);\n    if (!symbolTableEntry) {\n      return undefined;\n    }\n    if (symbolTableEntry.storageSpecifier !== \"typedef\") {\n      return undefined;\n    }\n    return symbolTableEntry.typename;\n  }\n\n  /**\n   * Use this function in parsing cast-expression and sizeof\n   */\n  function isCurrentTokenLooksLikeSpecifierQualifierList() {\n    const token = scanner.current();\n\n    const isIt =\n      isCurrentTokenTypeVoid() ||\n      isCurrentTokenTypeArithmeticSpecifier() ||\n      isCurrentTokenTypeUnderscoreSpecifier() ||\n      isCurrentTokenTypeQualifier() ||\n      token.type === \"signed\" ||\n      token.type === \"unsigned\" ||\n      token.type === \"struct\" ||\n      token.type === \"union\" ||\n      token.type === \"enum\" ||\n      isCurrentTokenTypedefName()\n        ? true\n        : false;\n\n    return isIt;\n  }\n\n  function isCurrentTokenLooksLikeTypeName() {\n    return isCurrentTokenLooksLikeSpecifierQualifierList();\n  }\n\n  function isCurrentTokenLooksLikeDeclarationSpecifiers() {\n    return isCurrentTokenLooksLikeSpecifierQualifierList() ||\n      isCurrentTokenAStorageClassSpecifier() ||\n      isCurrentTokenAFunctionSpecifier()\n      ? true\n      : false;\n  }\n\n  function isQualifiersListHaveDuplicates(qualifiers: TypeQualifier[]) {\n    return (\n      qualifiers.filter((s1, idx1) =>\n        qualifiers.find((s2, idx2) => s1 === s2 && idx1 !== idx2)\n      ).length > 0\n    );\n  }\n\n  function readDeclarationSpecifiers() {\n    const qualifiers: TypeQualifier[] = [];\n\n    let specifier: Typename | undefined = undefined;\n    let allowArithmeticTypeModification = true;\n\n    let signedUnsigned: TypeSignedUnsigned | undefined;\n\n    let storageClassSpecifier: StorageClass | null = null;\n    let functionSpecifier: \"inline\" | null = null;\n\n    const tokenForLocator = scanner.current();\n\n    while (true) {\n      const token = scanner.current();\n\n      const qualifier = isCurrentTokenTypeQualifier();\n\n      const maybeArithmeticSpecifier = isCurrentTokenTypeArithmeticSpecifier();\n\n      const maybeUnderscoreSpecifier = isCurrentTokenTypeUnderscoreSpecifier();\n\n      const maybeSpecifierFromSymbolTable = isCurrentTokenTypedefName();\n\n      const maybeStorageClassSpecifier = isCurrentTokenAStorageClassSpecifier();\n\n      const maybeFunctionSpecifier = isCurrentTokenAFunctionSpecifier();\n\n      if (qualifier) {\n        scanner.readNext();\n        qualifiers.push(qualifier);\n      } else if (isCurrentTokenTypeVoid()) {\n        if (specifier) {\n          throwError(\"Already have type specifier\");\n        }\n        scanner.readNext();\n        specifier = {\n          type: \"void\",\n          const: false,\n        };\n        allowArithmeticTypeModification = false;\n      } else if (maybeArithmeticSpecifier) {\n        scanner.readNext();\n\n        if (specifier) {\n          if (specifier.type !== \"arithmetic\") {\n            throwError(\"Already have non arithmetic type specifier\");\n          }\n          if (!allowArithmeticTypeModification) {\n            throwError(\"Not allowed to add specifiers to this type\");\n          }\n\n          // Same as below, treating \"long int\" as \"int\"\n          if (\n            specifier.arithmeticType === \"int\" &&\n            maybeArithmeticSpecifier === \"long\"\n          ) {\n            specifier.arithmeticType = \"int\";\n          } else {\n            throwError(\n              `TODO: Add 'long long' and others, modify specifier ` +\n                `s=${specifier.arithmeticType} m=${maybeArithmeticSpecifier} `\n            );\n          }\n        } else {\n          specifier = {\n            type: \"arithmetic\",\n            // Treating \"long\" as \"int\"\n            arithmeticType:\n              maybeArithmeticSpecifier === \"long\"\n                ? \"int\"\n                : maybeArithmeticSpecifier,\n            const: false,\n            signedUnsigned: null,\n          };\n        }\n      } else if (maybeUnderscoreSpecifier) {\n        if (specifier) {\n          throwError(\"Already have type specifier\");\n        }\n        throwError(\"Not implemented yet\");\n      } else if (token.type === \"signed\" || token.type === \"unsigned\") {\n        if (signedUnsigned) {\n          throwError(\"Already have signed/unsigned\");\n        }\n        scanner.readNext();\n        signedUnsigned = token.type;\n      } else if (token.type === \"struct\") {\n        throwError(\"Not implemented yet\");\n        // @TODO: Add into symbol table or lookup\n      } else if (token.type === \"union\") {\n        throwError(\"Not implemented yet\");\n        // @TODO: Add into symbol table or lookup\n      } else if (token.type === \"enum\") {\n        throwError(\"Not implemented yet\");\n        // @TODO: Add into symbol table or lookup\n      } else if (maybeSpecifierFromSymbolTable) {\n        if (specifier) {\n          throwError(\"Already have specifier\");\n        }\n        specifier = {\n          // Important to clone here - we might modify it\n          ...maybeSpecifierFromSymbolTable,\n        };\n        scanner.readNext();\n        allowArithmeticTypeModification = false;\n      } else if (maybeStorageClassSpecifier) {\n        if (storageClassSpecifier) {\n          throwError(\n            `Already have storage class specifier ${storageClassSpecifier}`\n          );\n        }\n        scanner.readNext();\n        storageClassSpecifier = maybeStorageClassSpecifier;\n      } else if (maybeFunctionSpecifier) {\n        if (functionSpecifier) {\n          throwError(`Already have function specifier`);\n        }\n        scanner.readNext();\n        functionSpecifier = maybeFunctionSpecifier;\n      } else {\n        break;\n      }\n    }\n\n    if (!specifier) {\n      // 6.7.2 Type specifiers\n      //  At least one type specifier shall be given\n      // C90 supports implicit-int, but not C99\n      // And it is quite hard to implement\n      // gcc gives a warning -Wimplicit-int\n      throwError(\"Expect specifier\");\n    }\n\n    if (signedUnsigned) {\n      if (specifier.type !== \"arithmetic\") {\n        throwError(\"Expecting arithmetic type for signed/unsigned\");\n      }\n      specifier.signedUnsigned = signedUnsigned;\n    }\n\n    if (qualifiers.indexOf(\"const\") > -1) {\n      if (specifier.type === \"void\") {\n        throwError(\"Unable to add const for void\");\n      }\n      specifier.const = true;\n    }\n\n    // @TODO: \"volatile\" and \"restrict\" qualifiers\n\n    if (isQualifiersListHaveDuplicates(qualifiers)) {\n      throwError(\"Got duplicated qualifiers\");\n    }\n\n    locator.set(specifier, {\n      ...tokenForLocator,\n      length: scanner.current().pos - tokenForLocator.pos,\n    });\n\n    return { specifier, storageClassSpecifier, functionSpecifier };\n  }\n\n  /*\n  function readPointers(base: Typename): Typename {\n    const token = scanner.current();\n    if (token.type !== \"*\") {\n      return base;\n    }\n    scanner.readNext();\n\n    const pointer: Typename = {\n      type: \"pointer\",\n      const: false,\n      pointsTo: base,\n    };\n\n    const qualifiers: TypeQualifier[] = [];\n    while (true) {\n      const qualifier = isCurrentTokenTypeQualifier();\n      if (qualifier) {\n        scanner.readNext();\n        qualifiers.push(qualifier);\n      } else {\n        break;\n      }\n    }\n\n    if (isQualifiersListHaveDuplicates(qualifiers)) {\n      throwError(\"Qualifiers have duplicates\");\n    }\n\n    if (qualifiers.indexOf(\"const\") > -1) {\n      pointer.const = true;\n    }\n\n    return readPointers(pointer);\n  }\n  */\n\n  /**\n   * Imagine this as nullable Typename, a chain of nested type where\n   *   last part is null because it is unknown at this moment.\n   * Example: When we read \"char (*) ...\", at the moment in parentheses\n   *   we know it will be a pointer, but we do not know yet what will it point to,\n   *   will it be just \"char\" or \"char[]\" or \"char()\"\n   *\n   * We have two operation: insert or append into that chain\n   *\n   * We also can defer some checks, for example if we got abstract-declarator, but\n   *   with storage class\n   *\n   */\n  type TypeCoreless = (base: Typename) => Typename;\n  type TypeOrDeclaratorCoreless =\n    | {\n        abstract: true;\n        chain: (base: Typename) => Typename;\n      }\n    | {\n        abstract: false;\n        chain: (base: Typename) => DeclaratorNode;\n      };\n\n  function readPointersCoreless(): TypeCoreless {\n    const token = scanner.current();\n    if (token.type !== \"*\") {\n      return (base) => base;\n    }\n    scanner.readNext();\n\n    const qualifiers: TypeQualifier[] = [];\n    while (true) {\n      const qualifier = isCurrentTokenTypeQualifier();\n      if (qualifier) {\n        scanner.readNext();\n        qualifiers.push(qualifier);\n      } else {\n        break;\n      }\n    }\n\n    if (isQualifiersListHaveDuplicates(qualifiers)) {\n      throwError(\"Qualifiers have duplicates\");\n    }\n    const isConst = qualifiers.indexOf(\"const\") > -1;\n\n    const nextPartCoreless = readPointersCoreless();\n\n    const myCoreless: TypeCoreless = (base) => {\n      const me: Typename = {\n        type: \"pointer\",\n        const: isConst,\n        pointsTo: base,\n      };\n      locator.set(me, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      const nextPart = nextPartCoreless(me);\n      return nextPart;\n    };\n\n    return myCoreless;\n  }\n\n  function readAbstractDeclaratorOrDeclaratorCoreless(): TypeOrDeclaratorCoreless {\n    const afterPointersCoreless = readPointersCoreless();\n\n    const directAbstractDeclaratorOrAbstractDeclaratorCoreless = readDirectAbstractDeclaratorOrDirectDeclaratorCoreless();\n\n    // Chain is the same\n    if (directAbstractDeclaratorOrAbstractDeclaratorCoreless.abstract) {\n      return {\n        abstract: true,\n        chain: (node) =>\n          directAbstractDeclaratorOrAbstractDeclaratorCoreless.chain(\n            afterPointersCoreless(node)\n          ),\n      };\n    } else {\n      return {\n        abstract: false,\n        chain: (node) =>\n          directAbstractDeclaratorOrAbstractDeclaratorCoreless.chain(\n            afterPointersCoreless(node)\n          ),\n      };\n    }\n  }\n\n  function readDirectAbstractDeclaratorOrDirectDeclaratorCoreless(): TypeOrDeclaratorCoreless {\n    // Here we have default, which allows this function to read empty declarator/abstract-declarator\n    let left: TypeCoreless = (node) => node;\n\n    let nestedAbstractDeclaratorOrDeclaratorOrIdentifier: TypeOrDeclaratorCoreless | null = null;\n\n    while (true) {\n      const token = scanner.current();\n\n      const isAbstractDeclarator =\n        !nestedAbstractDeclaratorOrDeclaratorOrIdentifier ||\n        nestedAbstractDeclaratorOrDeclaratorOrIdentifier.abstract;\n\n      if (token.type === \"(\") {\n        scanner.readNext();\n\n        const firstTokenInsideBracket = scanner.current();\n\n        if (\n          // We already have \"identifier\" or \"(declarator)\" or \"(abstract-declarator)\"\n          nestedAbstractDeclaratorOrDeclaratorOrIdentifier ||\n          // Or, it is () which is a function call\n          firstTokenInsideBracket.type === \")\" ||\n          // So, now it is possible to be:\n          //   - nested declarator in direct-declarator\n          //   - nested abstract-declarator in direct-abstract-declarator\n          //   - direct-abstract-declarator which declares function\n          //  \"declarator\" and \"direct-declarator\" can not start with declaration-specifier\n          isCurrentTokenLooksLikeDeclarationSpecifiers()\n        ) {\n          // Read \"parameter-type-list\" or \"identifier-list\" using isAbstractDeclarator\n          if (\n            isAbstractDeclarator ||\n            isCurrentTokenLooksLikeDeclarationSpecifiers() ||\n            // Assume no parameters is parameter-type-list\n            scanner.current().type === \")\"\n          ) {\n            const [parameters, ellipsis] =\n              scanner.current().type === \")\"\n                ? [[], false]\n                : readParameterTypeList();\n\n            const closing = scanner.current();\n            if (closing.type !== \")\") {\n              throwError(\"Expected )\");\n            }\n            scanner.readNext();\n\n            const savedLeft = left;\n            left = (node) => {\n              const me: Typename = {\n                type: \"function\",\n                const: true,\n                haveEndingEllipsis: ellipsis,\n                parameters: parameters,\n                returnType: node,\n              };\n              locator.set(me, {\n                ...token,\n                length: closing.pos - token.pos,\n              });\n              return savedLeft(me);\n            };\n          } else {\n            throw new Error(\"TODO Read identifier list for K&R notation\");\n          }\n        } else {\n          // Not a func call, but nested abstract-declarator or declarator\n          nestedAbstractDeclaratorOrDeclaratorOrIdentifier = readAbstractDeclaratorOrDeclaratorCoreless();\n\n          if (scanner.current().type !== \")\") {\n            throwError(\"Expected )\");\n          }\n          scanner.readNext();\n        }\n      } else if (token.type === \"[\") {\n        scanner.readNext();\n\n        // @TODO: Check other productions for direct-declarator,\n        // like with \"static\" keyword or with \"type-qualifier-list\"\n\n        let size: ExpressionNode | \"*\" | null = null;\n        if (scanner.current().type === \"*\") {\n          const nextSymbolIsClosingSquareBrace =\n            scanner.nextToken().type === \"]\";\n\n          if (nextSymbolIsClosingSquareBrace) {\n            size = \"*\";\n            scanner.readNext();\n          } else {\n            size = expressionReader.readAssignmentExpression();\n          }\n        } else if (scanner.current().type !== \"]\") {\n          size = expressionReader.readAssignmentExpression();\n        }\n\n        const closing = scanner.current();\n        if (closing.type !== \"]\") {\n          throwError(\"Expected ]\");\n        }\n        scanner.readNext();\n\n        const savedLeft = left;\n\n        left = (node) => {\n          const me: Typename = {\n            type: \"array\",\n            const: true,\n            size: size,\n            elementsTypename: node,\n          };\n          locator.set(me, {\n            ...token,\n            length: closing.pos - token.pos,\n          });\n          return savedLeft(me);\n        };\n      } else if (token.type === \"identifier\") {\n        scanner.readNext();\n        const afterIdentifierTokenForLocator = scanner.current();\n        // Aha, direct-declarator with identifier\n        // Must be null because we checked in above\n        nestedAbstractDeclaratorOrDeclaratorOrIdentifier = {\n          abstract: false,\n          chain: (typeNode) => {\n            const declaratorNode: DeclaratorNode = {\n              type: \"declarator\",\n              // Unknown yet\n              functionSpecifier: null,\n              // Unknown yet\n              storageSpecifier: null,\n              identifier: token.text,\n              typename: typeNode,\n              declaratorId: symbolTable.createDeclaratorId(),\n            };\n            locator.set(declaratorNode, {\n              ...token,\n              length: afterIdentifierTokenForLocator.pos - token.pos,\n            });\n            // It is not yet a complete declaration yet\n            return declaratorNode;\n          },\n        };\n      } else {\n        if (!nestedAbstractDeclaratorOrDeclaratorOrIdentifier) {\n          return {\n            abstract: true,\n            chain: (node) => left(node),\n          };\n        } else {\n          const saved = nestedAbstractDeclaratorOrDeclaratorOrIdentifier;\n          if (saved.abstract) {\n            return {\n              abstract: true,\n              chain: (node) => saved.chain(left(node)),\n            };\n          } else {\n            return {\n              abstract: false,\n              chain: (node) => saved.chain(left(node)),\n            };\n          }\n        }\n      }\n    }\n  }\n\n  function readTypeName() {\n    const {\n      specifier: baseSpecifier,\n      storageClassSpecifier,\n      functionSpecifier,\n    } = readDeclarationSpecifiers();\n\n    if (storageClassSpecifier) {\n      throwError(\"storage-class-specifier is not allowed in typeName\");\n    }\n    if (functionSpecifier) {\n      throwError(\"function-specifier is not allowed in typeName\");\n    }\n\n    const abstractDeclaratorOrDeclaratorCoreless = readAbstractDeclaratorOrDeclaratorCoreless();\n\n    if (!abstractDeclaratorOrDeclaratorCoreless.abstract) {\n      throwError(\"Non abstract declarator is not expected here\");\n    }\n\n    const typename = abstractDeclaratorOrDeclaratorCoreless.chain(\n      baseSpecifier\n    );\n\n    return typename;\n  }\n\n  function readParameterDeclaration() {\n    const {\n      specifier: baseSpecifier,\n      storageClassSpecifier,\n      functionSpecifier,\n    } = readDeclarationSpecifiers();\n\n    const declarator = readAbstractDeclaratorOrDeclaratorCoreless();\n\n    if (storageClassSpecifier && storageClassSpecifier !== \"register\") {\n      throwError(\n        \"Only register is allowed in parameter storage-class-specifier\"\n      );\n    }\n    if (functionSpecifier) {\n      throwError(\"Function specifier is not allowed in parameter declaration\");\n    }\n\n    if (declarator.abstract) {\n      // unnamed prototyped parameters\n      const typename = declarator.chain(baseSpecifier);\n      return typename;\n    } else {\n      const namedParameterDeclaration = declarator.chain(baseSpecifier);\n      return namedParameterDeclaration;\n    }\n  }\n\n  function readParameterTypeList() {\n    if (scanner.current().type === \"void\") {\n      scanner.readNext();\n      return [[] as DeclaratorNode[], false] as const;\n    }\n\n    const parameters: (DeclaratorNode | Typename)[] = [];\n    let ellipsis = false;\n    while (true) {\n      if (scanner.current().type === \"...\") {\n        ellipsis = true;\n        scanner.readNext();\n        break;\n      }\n\n      const parameter = readParameterDeclaration();\n      parameters.push(parameter);\n\n      if (scanner.current().type === \",\") {\n        scanner.readNext();\n      } else {\n        break;\n      }\n    }\n    return [parameters, ellipsis] as const;\n  }\n\n  /** Also adds declarations into symbolTable */\n  function readDeclaration() {\n    const nodes = readExternalDeclaration();\n\n    const resultNodes: DeclaratorNode[] = [];\n\n    for (const node of nodes) {\n      if (node.type === \"function-declaration\") {\n        throwError(\"Unexpected function declaration\");\n      } else {\n        resultNodes.push(node);\n      }\n    }\n    return resultNodes;\n  }\n\n  /** Adds declarations into symbolable */\n  function readExternalDeclaration() {\n    const tokenForLocator = scanner.current();\n\n    if (!isCurrentTokenLooksLikeDeclarationSpecifiers()) {\n      throwError(\"Expecting declaration-specifiers\");\n    }\n\n    const {\n      specifier: baseSpecifier,\n      storageClassSpecifier,\n      functionSpecifier,\n    } = readDeclarationSpecifiers();\n\n    const abstractDeclaratorOrDeclaratorCoreless = readAbstractDeclaratorOrDeclaratorCoreless();\n\n    if (abstractDeclaratorOrDeclaratorCoreless.abstract) {\n      throwError(\"Abstract declarator is not expected here\");\n    }\n\n    if (\n      scanner.current().type === \";\" ||\n      scanner.current().type === \",\" ||\n      scanner.current().type === \"=\"\n    ) {\n      const firstDeclaration = abstractDeclaratorOrDeclaratorCoreless.chain(\n        baseSpecifier\n      );\n      locator.set(firstDeclaration, {\n        ...tokenForLocator,\n        length: scanner.current().pos - tokenForLocator.pos,\n      });\n\n      let lastDeclaration: DeclaratorNode = firstDeclaration;\n      const declarationNodes: DeclaratorNode[] = [];\n      const pushDeclaration = () => {\n        lastDeclaration.functionSpecifier = functionSpecifier;\n        lastDeclaration.storageSpecifier = storageClassSpecifier;\n\n        declarationNodes.push(lastDeclaration);\n\n        symbolTable.addEntry(lastDeclaration);\n      };\n\n      while (scanner.current().type !== \";\") {\n        if (scanner.current().type === \"=\") {\n          scanner.readNext();\n          // An initializer\n          const initializerTokenForLocation = scanner.current();\n\n          if (!lastDeclaration) {\n            throwError(\"Internal error: declaration list is empty\");\n          }\n          if (lastDeclaration.initializer) {\n            throwError(\"Internal error: already have initializer\");\n          }\n\n          if (scanner.current().type === \"{\") {\n            throwError(\"initializer-list is not supported yet\");\n          }\n\n          const expression = expressionReader.readAssignmentExpression();\n\n          const initializer: InitializerNode = {\n            type: \"assigmnent-expression\",\n            expression: expression,\n          };\n          locator.set(initializer, {\n            ...initializerTokenForLocation,\n            length: scanner.current().pos - initializerTokenForLocation.pos,\n          });\n\n          lastDeclaration.initializer = initializer;\n        } else if ((scanner.current().type = \",\")) {\n          pushDeclaration();\n\n          scanner.readNext();\n          const declarator = readAbstractDeclaratorOrDeclaratorCoreless();\n\n          if (declarator.abstract) {\n            console.info(declarator);\n            throwError(\"Abstract declarator is not expected here\");\n          }\n\n          const declarationNode = declarator.chain(baseSpecifier);\n          locator.set(declarationNode, {\n            ...tokenForLocator,\n            length: scanner.current().pos - tokenForLocator.pos,\n          });\n          lastDeclaration = declarationNode;\n\n          // Initializers will be read in next iteration of this cycle\n        }\n      }\n      pushDeclaration();\n\n      scanner.readNext();\n\n      return declarationNodes;\n    }\n\n    // So, it is a function definition\n\n    const declaration = abstractDeclaratorOrDeclaratorCoreless.chain(\n      baseSpecifier\n    );\n    declaration.functionSpecifier = functionSpecifier;\n    declaration.storageSpecifier = storageClassSpecifier;\n\n    if (isCurrentTokenLooksLikeDeclarationSpecifiers()) {\n      throwError(\n        \"K&R notation, @TODO read declaration-list and then update function type\"\n      );\n    }\n\n    if (declaration.typename.type !== \"function\") {\n      throwError(\"Expecting function type (6.9.1 2)\");\n    }\n\n    if (declaration.typename.returnType.type === \"array\") {\n      throwError(\"Functions can not return array type (6.9.1 3)\");\n    }\n\n    if (\n      symbolTable.isIdentifierAlreadyDefinedInCurrentScope(\n        declaration.identifier\n      )\n    ) {\n      throwError(\"Idenitifier is already declared (TODO: do linkage)\");\n    }\n\n    // Workaround for typescript\n    const functionDeclaration: DeclaratorNodeFunction = {\n      ...declaration,\n      typename: declaration.typename,\n      initializer: null,\n    };\n\n    if (scanner.current().type !== \"{\") {\n      throwError(\"Expected compount-statement\");\n    }\n\n    symbolTable.addEntry(functionDeclaration);\n\n    symbolTable.enterFunctionScope();\n    for (const param of declaration.typename.parameters) {\n      if (param.type !== \"declarator\") {\n        throwError(\"Parameter name omitted\");\n      }\n      symbolTable.addEntry(param);\n    }\n\n    // Do this after we check for \"Parameter name omitted\" error\n    // So current token will show correct position\n    scanner.readNext();\n\n    const body = readCompoundStatementBody();\n\n    if (scanner.current().type !== \"}\") {\n      throwError(\"Expecting }\");\n    }\n    scanner.readNext();\n    const declaredVariables = symbolTable.leaveFunctionScope();\n\n    const func: FunctionDefinition = {\n      type: \"function-declaration\",\n      declaration: functionDeclaration,\n      body: body,\n      declaredVariables,\n    };\n\n    locator.set(func, {\n      ...tokenForLocator,\n      length: scanner.current().pos - tokenForLocator.pos,\n    });\n\n    return [func];\n  }\n\n  /**\n   * Automatically enters/leaves scope, so\n   * do not use it for function definition compount-statement\n   */\n  function readCompoundStatement() {\n    // TODO\n    // Or even no need to do because it is in readStatemen\n  }\n\n  function readStatement(): Statement {\n    const token = scanner.current();\n\n    if (token.type === \"case\" || token.type === \"default\") {\n      throwError(\"Case is not supported yet\");\n    } else if (\n      token.type === \"identifier\" &&\n      scanner.nextToken().type === \":\"\n    ) {\n      throwError(\"Labels are not supported yes\");\n    } else if (token.type === \"{\") {\n      // A compound-statement\n      symbolTable.enterScope();\n      scanner.readNext();\n      const body = readCompoundStatementBody();\n\n      if (scanner.current().type !== \"}\") {\n        throwError(\"Expected }\");\n      }\n      scanner.readNext();\n\n      const statement: CompoundStatement = {\n        type: \"compound-statement\",\n        body: body,\n      };\n      locator.set(statement, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      return statement;\n    } else if (token.type === \"if\") {\n      scanner.readNext();\n      if (scanner.current().type !== \"(\") {\n        throwError(\"Expected (\");\n      }\n      scanner.readNext();\n      const expression = expressionReader.readExpression();\n      if (scanner.current().type !== \")\") {\n        throwError(\"Expected )\");\n      }\n      scanner.readNext();\n\n      const iftrue = readStatement();\n\n      const iffalse = (() => {\n        if (scanner.current().type !== \"else\") {\n          return undefined;\n        }\n        scanner.readNext();\n        const statement = readStatement();\n        return statement;\n      })();\n\n      const node: IfStatement = {\n        type: \"if\",\n        condition: expression,\n        iftrue: iftrue,\n        iffalse: iffalse,\n      };\n\n      locator.set(node, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n\n      return node;\n    } else if (token.type === \"while\") {\n      scanner.readNext();\n\n      assertTokenAndReadNext(\"(\");\n\n      const condition = expressionReader.readExpression();\n\n      assertTokenAndReadNext(\")\");\n\n      const body = readStatement();\n\n      const node: WhileStatement = {\n        type: \"while\",\n        condition: condition,\n        body: body,\n      };\n      locator.set(node, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      return node;\n    } else if (token.type === \"do\") {\n      scanner.readNext();\n\n      const statement = readStatement();\n\n      assertTokenAndReadNext(\"while\");\n      assertTokenAndReadNext(\"(\");\n\n      const expression = expressionReader.readExpression();\n\n      assertTokenAndReadNext(\")\");\n      assertTokenAndReadNext(\";\");\n\n      const node: DoWhileStatement = {\n        type: \"dowhile\",\n        body: statement,\n        condition: expression,\n      };\n      locator.set(node, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      return node;\n    } else if (token.type === \"for\") {\n      scanner.readNext();\n\n      assertTokenAndReadNext(\"(\");\n\n      symbolTable.enterScope();\n\n      const firstStatement: CompoundStatementBody[] = [];\n      if (isCurrentTokenLooksLikeDeclarationSpecifiers()) {\n        const declarations = readDeclaration();\n        declarations.forEach((declaration) => firstStatement.push(declaration));\n      } else {\n        const firstExpression =\n          scanner.current().type !== \";\"\n            ? expressionReader.readExpression()\n            : undefined;\n        scanner.readNext();\n\n        const firstExpressionStatement:\n          | ExpressionStatement\n          | undefined = firstExpression\n          ? { type: \"expression\", expression: firstExpression }\n          : undefined;\n        if (firstExpression && firstExpressionStatement) {\n          const firstExpressionLocation = locator.get(firstExpression);\n          if (firstExpressionLocation) {\n            locator.set(firstExpressionStatement, firstExpressionLocation);\n          } else {\n            console.warn(\n              `No locator for first expression in \"for\"`,\n              firstExpression\n            );\n          }\n        }\n        if (firstExpressionStatement) {\n          firstStatement.push(firstExpressionStatement);\n        }\n      }\n\n      const secondExpression =\n        scanner.current().type !== \";\"\n          ? expressionReader.readExpression()\n          : undefined;\n      scanner.readNext();\n\n      const thirdExpression =\n        scanner.current().type !== \")\"\n          ? expressionReader.readExpression()\n          : undefined;\n\n      const thirdExpressionStatement:\n        | ExpressionStatement\n        | undefined = thirdExpression\n        ? { type: \"expression\", expression: thirdExpression }\n        : undefined;\n      if (thirdExpressionStatement && thirdExpression) {\n        const thirdExpressionLocation = locator.get(thirdExpression);\n        if (thirdExpressionLocation) {\n          locator.set(thirdExpressionStatement, thirdExpressionLocation);\n        } else {\n          console.warn(\n            `No locator for third expression in \"for\"`,\n            thirdExpressionStatement\n          );\n        }\n      }\n\n      assertTokenAndReadNext(\")\");\n\n      const statement = readStatement();\n\n      symbolTable.leaveScope();\n\n      const secondExpressionConst = {\n        type: \"const\",\n        subtype: \"char\",\n        // 6.8.5.3  2\n        value: 1,\n      } as ExpressionNode;\n      if (!secondExpression) {\n        // TODO: not a perfect locator\n        locator.set(secondExpressionConst, {\n          ...token,\n          length: scanner.current().pos - token.pos,\n        });\n      }\n\n      const thirdExpressionStatementCompoundStatement: CompoundStatement | null = thirdExpressionStatement\n        ? {\n            type: \"compound-statement\",\n            body: [statement, thirdExpressionStatement],\n          }\n        : null;\n      if (thirdExpressionStatementCompoundStatement) {\n        // TODO: not a perfect locator\n        locator.set(thirdExpressionStatementCompoundStatement, {\n          ...token,\n          length: scanner.current().pos - token.pos,\n        });\n      }\n\n      const innerNode: WhileStatement = {\n        type: \"while\",\n        condition: secondExpression ? secondExpression : secondExpressionConst,\n        body: thirdExpressionStatementCompoundStatement\n          ? thirdExpressionStatementCompoundStatement\n          : statement,\n      };\n      locator.set(innerNode, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n\n      if (firstStatement.length === 0) {\n        return innerNode;\n      } else {\n        const node: CompoundStatement = {\n          type: \"compound-statement\",\n          body: [...firstStatement, innerNode],\n        };\n        locator.set(node, {\n          ...token,\n          length: scanner.current().pos - token.pos,\n        });\n\n        return node;\n      }\n    } else if (token.type === \";\") {\n      scanner.readNext();\n      const emptyExpressionStatement: EmpryExpressionStatement = {\n        type: \"noop\",\n      };\n      locator.set(emptyExpressionStatement, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      return emptyExpressionStatement;\n    } else if (token.type === \"continue\") {\n      scanner.readNext();\n      assertTokenAndReadNext(\";\");\n\n      const node: ContinueStatement = {\n        type: \"continue\",\n      };\n      locator.set(node, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      return node;\n    } else if (token.type === \"break\") {\n      scanner.readNext();\n      assertTokenAndReadNext(\";\");\n\n      const node: BreakStatement = {\n        type: \"break\",\n      };\n      locator.set(node, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      return node;\n    } else if (token.type === \"return\") {\n      scanner.readNext();\n      const expression =\n        scanner.current().type === \";\"\n          ? undefined\n          : expressionReader.readExpression();\n\n      assertTokenAndReadNext(\";\");\n\n      const node: ReturnStatement = {\n        type: \"return\",\n        expression: expression,\n      };\n      locator.set(node, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      return node;\n    } else {\n      const expression = expressionReader.readExpression();\n      if (scanner.current().type !== \";\") {\n        throwError(\"Expected ; after expression\");\n      }\n      scanner.readNext();\n\n      const node: ExpressionStatement = {\n        type: \"expression\",\n        expression: expression,\n      };\n      locator.set(node, {\n        ...token,\n        length: scanner.current().pos - token.pos,\n      });\n      return node;\n    }\n  }\n\n  function readCompoundStatementBody() {\n    const body: CompoundStatementBody[] = [];\n\n    while (scanner.current().type !== \"end\" && scanner.current().type !== \"}\") {\n      if (isCurrentTokenLooksLikeDeclarationSpecifiers()) {\n        const declarations = readDeclaration();\n        declarations.forEach((declaration) => body.push(declaration));\n      } else {\n        const statement = readStatement();\n        body.push(statement);\n      }\n    }\n\n    return body;\n  }\n\n  return {\n    ...expressionReader,\n    readTypeName,\n    isCurrentTokenLooksLikeTypeName,\n    isCurrentTokenLooksLikeDeclarationSpecifiers,\n    readExternalDeclaration,\n    readDeclaration,\n    readCompoundStatementBody,\n  };\n}\n","import {\n  ExternalDeclarations,\n  NodeLocator,\n  TranslationUnit,\n} from \"./parser.definitions\";\nimport { Scanner } from \"./scanner\";\nimport { SymbolTable } from \"./parser.symboltable\";\nimport { createParser } from \"./parser.funcs\";\n\nexport function readTranslationUnit(scanner: Scanner) {\n  const locator: NodeLocator = new Map();\n  const symbolTable = new SymbolTable(locator);\n  symbolTable.enterScope();\n\n  const parser = createParser(scanner, locator, symbolTable);\n\n  const body: ExternalDeclarations = [];\n  while (scanner.current().type !== \"end\") {\n    if (scanner.current().type === \";\") {\n      // This is not in standard\n      scanner.readNext();\n      continue;\n    }\n    const nodes: ExternalDeclarations = parser.readExternalDeclaration();\n    nodes.forEach((node) => body.push(node));\n  }\n\n  const declarations = symbolTable.getTranslationUnittDeclarations();\n\n  const declaratorMap = symbolTable.getDeclaratorsMap();\n\n  const translationUnit: TranslationUnit = {\n    type: \"translation-unit\",\n    body: body,\n    declarations: declarations,\n    declaratorMap: () => declaratorMap,\n    locationMap: () => locator,\n  };\n  return translationUnit;\n}\n","export function assertNever(x: never): never {\n  throw new Error(`Unexpected object: ${x}`);\n}\n","import { Typename } from \"./parser.definitions\";\nimport { assertNever } from \"./assertNever\";\nimport { RegisterType, WAInstuction } from \"./emitter.definitions\";\n\nexport function getRegisterForTypename(\n  typename: Typename\n): RegisterType | null {\n  if (typename.type === \"arithmetic\") {\n    if (\n      typename.arithmeticType === \"char\" ||\n      typename.arithmeticType === \"short\" ||\n      typename.arithmeticType === \"int\"\n    ) {\n      return \"i32\" as const;\n    } else if (typename.arithmeticType === \"long long\") {\n      return \"i64\" as const;\n    } else if (typename.arithmeticType === \"float\") {\n      return \"f32\" as const;\n    } else if (typename.arithmeticType === \"double\") {\n      return \"f64\" as const;\n    } else {\n      assertNever(typename.arithmeticType);\n    }\n  } else if (typename.type === \"pointer\") {\n    return \"i32\" as const;\n  } else {\n    // TODO: enums are in registers too\n    return null;\n  }\n}\n\nexport const readEspCode: WAInstuction[] = [\n  `i32.const 4 ;; Read $esp`,\n  \"i32.load offset=0 align=2 ;; Read $esp\",\n];\nexport const writeEspCode = (value: WAInstuction[]) => [\n  `i32.const 4 ;; Prepare $esp write - address`,\n  ...value,\n  `i32.store offset=0 align=2 ;; Write $esp`,\n];\n","import { FunctionTypename } from \"./parser.definitions\";\nimport { getRegisterForTypename } from \"./emitter.utils\";\nimport { RegisterType, WAInstuction } from \"./emitter.definitions\";\nimport { type } from \"os\";\n\nfunction registerToShortname(register: RegisterType) {\n  return {\n    i32: \"i\",\n    i64: \"j\",\n    f32: \"f\",\n    f64: \"d\",\n  }[register];\n}\n\n/** Exported only for autotests, do not use it */\nexport function generateFunctionWaTypeName(func: FunctionTypename) {\n  const returnRegister = getRegisterForTypename(func.returnType);\n\n  const returnTypeNamePart =\n    func.returnType.type === \"void\"\n      ? \"v\"\n      : returnRegister\n      ? registerToShortname(returnRegister)\n      : null;\n\n  if (!returnTypeNamePart) {\n    // No locator here\n    throw new Error(\"Return of non-register value is not supported yet\");\n  }\n  const waTypeDefinitionResult = returnRegister\n    ? ` (result ${returnRegister})`\n    : \"\";\n\n  let waTypeDefinitionParams = \"\";\n\n  let waTypeName = \"$FUNCSIG\" + returnTypeNamePart;\n  for (const param of func.parameters) {\n    const paramTypename = param.type === \"declarator\" ? param.typename : param;\n\n    const paramRegister = getRegisterForTypename(paramTypename);\n    if (!paramRegister) {\n      console.info(paramTypename);\n      throw new Error(\n        `Parameters with non-register values is not supported yet`\n      );\n    }\n\n    const paramRegisterTypeNamePart = registerToShortname(paramRegister);\n\n    waTypeName += paramRegisterTypeNamePart;\n    waTypeDefinitionParams += ` ${paramRegister}`;\n  }\n\n  if (func.haveEndingEllipsis) {\n    throw new Error(\"'...' is not implemened yed\");\n  }\n\n  const waTypeDefinition =\n    \"(func\" +\n    (waTypeDefinitionParams ? ` (param${waTypeDefinitionParams})` : \"\") +\n    waTypeDefinitionResult +\n    \")\";\n\n  return [waTypeName, waTypeDefinition];\n}\n\nexport class FunctionSignatures {\n  constructor() {}\n\n  /**\n   * A map, something like this\n   *\n   * $FUNCSIG$iij -> (func (param i32 i64) (result i32)))\n   */\n  private readonly seenFunctionTypes = new Map<string, string>();\n\n  getFunctionTypeName(func: FunctionTypename) {\n    const [waTypeName, waTypeDefinition] = generateFunctionWaTypeName(func);\n    if (!this.seenFunctionTypes.has(waTypeName)) {\n      this.seenFunctionTypes.set(waTypeName, waTypeDefinition);\n    }\n    return waTypeName;\n  }\n\n  getTypesWAInstructions(): WAInstuction[] {\n    return [...this.seenFunctionTypes.entries()].map(\n      ([waTypeName, waTypeDefinition]) =>\n        `(type ${waTypeName} ${waTypeDefinition})`\n    );\n  }\n}\n","import {\n  DeclaratorId,\n  DeclaratorNode,\n  NodeLocator,\n  DeclaratorMap,\n  Node,\n} from \"./parser.definitions\";\nimport { CheckerError } from \"./error\";\nimport { CheckerWarning } from \"./emitter.definitions\";\nimport { FunctionSignatures } from \"./emitter.helpers.functionsignature\";\n\nexport interface EmitterHelpers {\n  error(node: Node, msg: string): never;\n  warn(node: Node, msg: string): void;\n  cloneLocation(fromNode: Node, toNode: Node): void;\n  getDeclaration(declaratorId: DeclaratorId): DeclaratorNode;\n  warnings: CheckerWarning[];\n  functionSignatures: FunctionSignatures;\n}\n\nexport function createHelpers(\n  locator: NodeLocator,\n  declaratorMap: DeclaratorMap\n): EmitterHelpers {\n  const warnings: CheckerWarning[] = [];\n\n  function getDeclaration(declaratorId: DeclaratorId) {\n    const declaration = declaratorMap.get(declaratorId);\n    if (!declaration) {\n      throw new Error(\n        `Internal error: unable to find declaration ${declaratorId}`\n      );\n    }\n    return declaration;\n  }\n\n  function cloneLocation(fromNode: Node, toNode: Node) {\n    const location = locator.get(fromNode);\n    if (!location) {\n      console.warn(`No location for node`, fromNode);\n      return;\n    }\n    locator.set(toNode, location);\n  }\n\n  function warn(node: Node, msg: string) {\n    const location = locator.get(node);\n    if (!location) {\n      console.warn(`Unable to find location for node type=${node.type}`);\n      warnings.push({\n        msg,\n        length: 0,\n        pos: 0,\n        line: 0,\n      });\n    } else {\n      warnings.push({\n        msg,\n        ...location,\n      });\n    }\n  }\n  function error(node: Node, msg: string): never {\n    // TODO: Add error into errors list\n    // Now we just throw\n    const location = locator.get(node);\n    if (!location) {\n      console.warn(`Unable to find location for node type=${node.type}`);\n      throw new CheckerError(`${msg}`, { pos: 0, line: 0, length: 0 });\n    } else {\n      throw new CheckerError(`${msg}`, location);\n    }\n  }\n\n  const functionSignatures = new FunctionSignatures();\n\n  return {\n    error,\n    warn,\n    cloneLocation,\n    getDeclaration,\n    warnings,\n    functionSignatures,\n  };\n}\n","import { Typename } from \"./parser.definitions\";\nimport { assertNever } from \"./assertNever\";\nimport { RegisterType, WAInstuction } from \"./emitter.definitions\";\n\nfunction addOffsetAlign(\n  instruction: WAInstuction,\n  offset: number,\n  align: number,\n  maxAlign: number\n) {\n  const realAlign = Math.min(align, maxAlign);\n  return (\n    instruction +\n    ((offset !== 0 ? ` offset=${offset}` : \"\") +\n      (realAlign !== 0 ? ` align=${realAlign}` : \"\"))\n  );\n}\n\nexport function storeScalar(\n  typename: Typename,\n  fromRegister: RegisterType,\n  offset = 0,\n  align = 0\n): WAInstuction {\n  if (typename.type === \"arithmetic\") {\n    if (typename.arithmeticType === \"char\") {\n      if (fromRegister !== \"i32\" && fromRegister !== \"i64\") {\n        throw new Error(\n          `Internal error: unable to save char from ${fromRegister} register`\n        );\n      }\n      return addOffsetAlign(`${fromRegister}.store8`, offset, align, 0);\n    } else if (typename.arithmeticType === \"short\") {\n      if (fromRegister !== \"i32\" && fromRegister !== \"i64\") {\n        throw new Error(\n          `Internal error: unable to save short from ${fromRegister} register`\n        );\n      }\n      return addOffsetAlign(`${fromRegister}.store16`, offset, align, 1);\n    } else if (typename.arithmeticType === \"int\") {\n      if (fromRegister === \"i32\") {\n        return addOffsetAlign(`i32.store`, offset, align, 2);\n      } else if (fromRegister === \"i64\") {\n        return addOffsetAlign(`i64.store32`, offset, align, 2);\n      } else {\n        throw new Error(\n          `Internal error: unable to save int from ${fromRegister} register`\n        );\n      }\n    } else if (typename.arithmeticType === \"long long\") {\n      if (fromRegister !== \"i64\") {\n        throw new Error(\n          `Internal error: unable to save longlong from ${fromRegister} register`\n        );\n      }\n      return addOffsetAlign(`i64.store`, offset, align, 2);\n    } else if (\n      typename.arithmeticType === \"double\" ||\n      typename.arithmeticType === \"float\"\n    ) {\n      throw new Error(\"TOOD: Store float/double\");\n    } else {\n      assertNever(typename.arithmeticType);\n    }\n  } else if (typename.type === \"pointer\") {\n    return addOffsetAlign(`i32.store`, offset, align, 2);\n  }\n  throw new Error(\n    `Wrong usage, expecting only scalar types but got type=${typename.type}`\n  );\n}\n\nexport function loadScalar(\n  t: Typename,\n  toRegister: RegisterType,\n  offset = 0,\n  alignment = 0\n): WAInstuction {\n  if (toRegister !== \"i32\") {\n    throw new Error(\"Not supported yet\");\n  }\n  if (t.type === \"pointer\") {\n    return addOffsetAlign(`i32.load`, offset, alignment, 2);\n  }\n\n  if (t.type !== \"arithmetic\") {\n    throw new Error(\"Internal error\");\n  }\n  if (t.arithmeticType === \"int\") {\n    return (\n      addOffsetAlign(`i32.load`, offset, alignment, 2) + `;; readArithmetic int`\n    );\n  } else if (t.arithmeticType === \"char\") {\n    if (t.signedUnsigned === \"signed\") {\n      return (\n        addOffsetAlign(`i32.load8_s`, offset, alignment, 0) +\n        `;; readArithmetic signed chat`\n      );\n    } else {\n      return (\n        addOffsetAlign(`i32.load8_u`, offset, alignment, 0) +\n        `;; readArithmetic signed chat`\n      );\n    }\n  }\n  throw new Error(\"Internal error or not suppored yet\");\n}\n","import { Typename } from \"./parser.definitions\";\n\n/**\n * Returns true if typename is scalar = arithmetic||pointer\n */\nexport function isScalar(typename: Typename) {\n  return typename.type === \"arithmetic\" || typename.type === \"pointer\";\n}\n","import { ExpressionNode, Typename, Node } from \"./parser.definitions\";\nimport { ExpressionInfo, WAInstuction } from \"./emitter.definitions\";\nimport { assertNever } from \"./assertNever\";\nimport { EmitterHelpers } from \"./emitter.helpers\";\nimport { getRegisterForTypename } from \"./emitter.utils\";\nimport { storeScalar, loadScalar } from \"./emitter.scalar.storeload\";\nimport { isScalar } from \"./emitter.scalar\";\n\nexport type TypeSize =\n  | {\n      type: \"static\";\n      value: number;\n    }\n  | {\n      type: \"incomplete\";\n    }\n  | {\n      type: \"expression\";\n      expression: ExpressionNode;\n    };\n\nexport type TypeSizeGetter = (typename: Typename) => TypeSize;\n\nexport type ExpressionInfoGetter = (\n  expression: ExpressionNode\n) => ExpressionInfo;\n\nexport interface ExpressionAndTypes {\n  getTypeSize: TypeSizeGetter;\n  getExpressionInfo: ExpressionInfoGetter;\n}\n\nexport function createExpressionAndTypes(\n  helpers: EmitterHelpers\n): ExpressionAndTypes {\n  const { warn, cloneLocation, getDeclaration } = helpers;\n\n  function error(node: Node, msg: string): never {\n    helpers.error(node, msg);\n  }\n\n  const getTypeSize: TypeSizeGetter = (typename) => {\n    // Fixed size = number\n    // Depended size = expression\n    // Incomplete = undefined\n    const staticSize = (value: number): TypeSize => ({\n      type: \"static\",\n      value: value,\n    });\n    const incomleteSize: TypeSize = {\n      type: \"incomplete\",\n    };\n    const expressionSize = (expression: ExpressionNode): TypeSize => ({\n      type: \"expression\",\n      expression: expression,\n    });\n\n    if (typename.type === \"arithmetic\") {\n      if (typename.arithmeticType === \"char\") {\n        return staticSize(1);\n      } else if (typename.arithmeticType === \"int\") {\n        return staticSize(4);\n      } else {\n        error(typename, \"Not supported yet\");\n      }\n    } else if (typename.type === \"array\") {\n      const elementSize = getTypeSize(typename.elementsTypename);\n\n      if (typename.size === null) {\n        return incomleteSize;\n      }\n      if (typename.size === \"*\") {\n        error(typename, \"Star in array is not supported\");\n      }\n\n      const size = getExpressionInfo(typename.size);\n\n      if (elementSize.type === \"static\" && size.staticValue) {\n        return staticSize(elementSize.value * size.staticValue);\n      } else {\n        error(\n          typename,\n          \"Dynamic arrays are not supported yet. Todo: return created expression for size if possible\"\n        );\n      }\n    } else if (typename.type === \"enum\" || typename.type === \"struct\") {\n      error(typename, \"Not supported yet\");\n    } else if (\n      typename.type === \"function\" ||\n      typename.type === \"function-knr\"\n    ) {\n      error(\n        typename,\n        \"6.5.3.4: The sizeof operator shall not be applied to an expression that has function type\"\n      );\n    } else if (typename.type === \"pointer\") {\n      return staticSize(4);\n    } else if (typename.type === \"void\") {\n      error(typename, \"Void have no size\");\n    } else {\n      assertNever(typename);\n    }\n  };\n\n  const isArrayStaticSize = (node: Typename) => {\n    if (node.type !== \"array\") {\n      throw new Error(\"Internal error: isArrayStaticSize called for non-array\");\n    }\n    const size = getTypeSize(node);\n    if (size.type === \"static\") {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const getExpressionInfo = (expression: ExpressionNode): ExpressionInfo => {\n    if (expression.type === \"const\") {\n      // TODO: Change ExperssionNode type to hold stringified value instead of number\n      if (expression.subtype === \"char\") {\n        if (expression.value > 255) {\n          throw new Error(\"Assertion failed: char > 255\");\n        }\n        if (expression.value < -128) {\n          throw new Error(\"Assertion failed: char < -128\");\n        }\n        const typeNode: Typename = {\n          type: \"arithmetic\",\n          arithmeticType: \"char\",\n          const: true,\n          signedUnsigned: expression.value >= 0 ? null : \"signed\",\n        };\n        cloneLocation(expression, typeNode);\n        return {\n          type: typeNode,\n          value: () => [`i32.const ${expression.value}`],\n          address: null,\n          staticValue: expression.value,\n        };\n      } else if (expression.subtype === \"int\") {\n        const INT_MIN = -(2 ** 31);\n        const UINT_MAX = 2 ** 32 - 1;\n        if (expression.value <= UINT_MAX && expression.value >= INT_MIN) {\n          // Always store as 4 bytes because our registers are 4 bytes\n          const typeNode: Typename = {\n            type: \"arithmetic\",\n            arithmeticType: \"int\",\n            const: true,\n            signedUnsigned: expression.value >= 0 ? null : \"signed\",\n          };\n          cloneLocation(expression, typeNode);\n          return {\n            type: typeNode,\n            value: () => [`i32.const ${expression.value}`],\n            address: null,\n            staticValue: expression.value,\n          };\n        } else {\n          const typeNode: Typename = {\n            type: \"arithmetic\",\n            arithmeticType: \"long long\",\n            const: true,\n            signedUnsigned: expression.value >= 0 ? null : \"signed\",\n          };\n          cloneLocation(expression, typeNode);\n          return {\n            type: typeNode,\n            value: () => [`i64.const ${expression.value}`],\n            address: null,\n            staticValue: expression.value,\n          };\n        }\n      } else if (expression.subtype === \"float\") {\n        error(expression, \"Floats are not supported yet\");\n      }\n    } else if (expression.type === \"identifier\") {\n      const declaration = getDeclaration(expression.declaratorNodeId);\n      if (declaration.typename.type === \"arithmetic\") {\n        if (\n          declaration.typename.arithmeticType === \"char\" ||\n          declaration.typename.arithmeticType === \"int\"\n        ) {\n          let staticValue: number | null = null;\n          if (\n            declaration.typename.const /** todo: check volatile */ &&\n            declaration.initializer &&\n            declaration.initializer.type === \"assigmnent-expression\"\n          ) {\n            const initializerInfo = getExpressionInfo(\n              declaration.initializer.expression\n            );\n            if (initializerInfo.staticValue) {\n              staticValue = initializerInfo.staticValue;\n            }\n          }\n          return {\n            type: declaration.typename,\n            staticValue: staticValue,\n            value: () =>\n              declaration.memoryIsGlobal\n                ? [\n                    `i32.const ${declaration.memoryOffset}`,\n                    loadScalar(declaration.typename, \"i32\", 0, 2),\n                  ]\n                : [\n                    `local.get $ebp`,\n                    loadScalar(\n                      declaration.typename,\n                      \"i32\",\n                      declaration.memoryOffset,\n                      2\n                    ),\n                  ],\n            address: () =>\n              declaration.memoryIsGlobal\n                ? [`i32.const ${declaration.memoryOffset}`]\n                : [\n                    `local.get $ebp`,\n                    `i32.const ${declaration.memoryOffset}`,\n                    `i32.add`,\n                  ],\n          };\n        } else if (\n          declaration.typename.arithmeticType === \"double\" ||\n          declaration.typename.arithmeticType === \"float\"\n        ) {\n          error(expression, \"Floats are not supported yet\");\n        } else {\n          error(expression, \"TODO support other types\");\n        }\n      } else if (declaration.typename.type === \"function-knr\") {\n        error(\n          declaration,\n          \"Internal error: K&R notations should be replated to this point\"\n        );\n      } else if (declaration.typename.type === \"function\") {\n        return {\n          type: declaration.typename,\n          staticValue: declaration.memoryOffset\n            ? declaration.memoryOffset\n            : null,\n          value: () => [`i32.const ${declaration.memoryOffset}`],\n          address: () => [`i32.const ${declaration.memoryOffset}`],\n        };\n      } else if (declaration.typename.type === \"pointer\") {\n        return {\n          type: declaration.typename,\n          staticValue: null,\n          value: () =>\n            declaration.memoryIsGlobal\n              ? [\n                  `i32.const ${declaration.memoryOffset}`,\n                  loadScalar(declaration.typename, \"i32\", 0, 2),\n                ]\n              : [\n                  `local.get $ebp`,\n                  loadScalar(\n                    declaration.typename,\n                    \"i32\",\n                    declaration.memoryOffset,\n                    2\n                  ),\n                ],\n          address: () =>\n            declaration.memoryIsGlobal\n              ? [`i32.const ${declaration.memoryOffset}`]\n              : [\n                  `local.get $ebp`,\n                  `i32.const ${declaration.memoryOffset}`,\n                  `i32.add`,\n                ],\n        };\n      } else if (declaration.typename.type === \"array\") {\n        if (!isArrayStaticSize(declaration.typename)) {\n          error(declaration, \"TODO: Dynamic arrays are not supported yet\");\n        }\n\n        return {\n          type: declaration.typename,\n          staticValue: null,\n          value: null,\n          address: () => {\n            return declaration.memoryIsGlobal\n              ? [`i32.const ${declaration.memoryOffset}`]\n              : [\n                  `local.get $ebp`,\n                  `i32.const ${declaration.memoryOffset}`,\n                  `i32.add`,\n                ];\n          },\n        };\n      } else if (\n        declaration.typename.type === \"enum\" ||\n        declaration.typename.type === \"struct\"\n      ) {\n        error(declaration, \"TODO, not implemented yett\");\n      } else if (declaration.typename.type === \"void\") {\n        error(declaration, \"Used void declaration\");\n      } else {\n        assertNever(declaration.typename);\n      }\n    } else if (expression.type === \"subscript operator\") {\n      const target = expression.target;\n      const index = expression.index;\n      const targetInfo = getExpressionInfo(target);\n      const indexInfo = getExpressionInfo(index);\n\n      if (indexInfo.type.type !== \"arithmetic\") {\n        error(index, \"Must be arithmetic type\");\n      }\n      if (\n        indexInfo.type.arithmeticType !== \"int\" &&\n        indexInfo.type.arithmeticType !== \"char\"\n      ) {\n        error(index, \"Only int/char are supported now\");\n      }\n      if (targetInfo.type.type === \"array\") {\n        const elementsSize = getTypeSize(targetInfo.type.elementsTypename);\n        if (elementsSize.type !== \"static\") {\n          error(\n            targetInfo.type.elementsTypename,\n            \"Dynamic arrays are not supported yet\"\n          );\n        }\n\n        if (!targetInfo.address) {\n          error(target, \"Array must have address\");\n        }\n        const getArrayAddress = targetInfo.address;\n\n        if (!indexInfo.value) {\n          error(index, \"Must be a value here\");\n        }\n\n        const getIndexValue = indexInfo.value;\n\n        const getArrayElementAddress = () => {\n          const indexOffset: WAInstuction[] = [\n            ...getIndexValue(),\n            `i32.const ${elementsSize.value}`,\n            `i32.mul`,\n          ];\n          return [...getArrayAddress(), ...indexOffset, `i32.add`];\n        };\n\n        const elementsTypename = targetInfo.type.elementsTypename;\n        const getArrayElementValue = isScalar(elementsTypename)\n          ? () => [\n              ...getArrayElementAddress(),\n              // We might know alignment if we know array size\n              // For example, if elements size >= 4, then alignment could be equal 2\n              loadScalar(elementsTypename, \"i32\", 0, 0),\n            ]\n          : null;\n\n        return {\n          type: targetInfo.type.elementsTypename,\n          staticValue: null,\n          value: getArrayElementValue,\n          address: getArrayElementAddress,\n        };\n      } else if (targetInfo.type.type === \"pointer\") {\n        const elementsSize = getTypeSize(targetInfo.type.pointsTo);\n        if (elementsSize.type === \"incomplete\") {\n          error(target, \"subscript of pointer to incomplete type\");\n        }\n        if (elementsSize.type === \"expression\") {\n          error(target, \"Dynamic array types is not supported yet\");\n        }\n\n        if (!targetInfo.value) {\n          error(target, \"Pointter must have address\");\n        }\n        const getPointerTargetAddress = targetInfo.value;\n\n        if (!indexInfo.value) {\n          error(index, \"Must be a value here\");\n        }\n\n        const getIndexValue = indexInfo.value;\n\n        const getArrayElementAddress = () => {\n          const indexOffset: WAInstuction[] = [\n            ...getIndexValue(),\n            `i32.const ${elementsSize.value}`,\n            `i32.mul`,\n          ];\n          return [...getPointerTargetAddress(), ...indexOffset, `i32.add`];\n        };\n\n        const elementsTypename = targetInfo.type.pointsTo;\n        const getArrayElementValue = isScalar(elementsTypename)\n          ? () => [\n              ...getArrayElementAddress(),\n              // We might know alignment if we know array size\n              // For example, if elements size >= 4, then alignment could be equal 2\n              loadScalar(elementsTypename, \"i32\", 0, 0),\n            ]\n          : null;\n\n        return {\n          type: targetInfo.type.pointsTo,\n          staticValue: null,\n          value: getArrayElementValue,\n          address: getArrayElementAddress,\n        };\n      } else {\n        error(target, \"Must be array or pointer type\");\n      }\n    } else if (expression.type === \"function call\") {\n      const targetInfo = getExpressionInfo(expression.target);\n      if (targetInfo.type.type !== \"function\") {\n        error(expression.target, \"Must be a function\");\n      }\n      const targetInfoValue = targetInfo.value;\n      if (!targetInfoValue) {\n        error(expression.target, `There must be a function value`);\n      }\n      const func = targetInfo.type;\n      if (func.parameters.length > expression.args.length) {\n        error(expression, `Not ennough parameters`);\n      }\n      if (func.parameters.length < expression.args.length) {\n        if (func.haveEndingEllipsis) {\n          error(expression, `Ellipsis is not implemented yet`);\n        } else {\n          error(expression, `Too many parameters for this function`);\n        }\n      }\n\n      const argsValueGetters: (() => WAInstuction[])[] = [];\n      for (let idx = 0; idx < expression.args.length; idx++) {\n        const arg = expression.args[idx];\n        const paramDefinition = func.parameters[idx];\n\n        const argInfo = getExpressionInfo(arg);\n        const funcArgRegister = getRegisterForTypename(argInfo.type);\n        if (!funcArgRegister) {\n          error(arg, `Non-register params are not supported yet`);\n        }\n\n        const paramDefinitionRegister = getRegisterForTypename(\n          paramDefinition.type === \"declarator\"\n            ? paramDefinition.typename\n            : paramDefinition\n        );\n        if (!paramDefinitionRegister) {\n          error(arg, `Non-register params are not supportetd yet1`);\n        }\n        if (paramDefinitionRegister !== funcArgRegister) {\n          error(arg, `Register promotion is not supported yet`);\n        }\n\n        const argValue = argInfo.value;\n        if (!argValue) {\n          error(arg, `Must have a value for register param`);\n        }\n        argsValueGetters.push(argValue);\n      }\n\n      const waTypeName = helpers.functionSignatures.getFunctionTypeName(func);\n\n      return {\n        type: func.returnType,\n        address: null,\n        staticValue: null,\n        value: () => {\n          const functionValueCode: WAInstuction[] = [];\n          argsValueGetters.forEach((f) => functionValueCode.push(...f()));\n\n          if (targetInfo.staticValue) {\n            functionValueCode.push(`call ${targetInfo.staticValue}`);\n          } else {\n            functionValueCode.push(...targetInfoValue());\n            functionValueCode.push(`call_indirect (type ${waTypeName})`);\n          }\n          return functionValueCode;\n        },\n      };\n    } else if (expression.type === \"binary operator\") {\n      const leftInfo = getExpressionInfo(expression.left);\n      const rightInfo = getExpressionInfo(expression.right);\n\n      const op = expression.operator;\n\n      const getLeftValue = leftInfo.value;\n      if (!getLeftValue) {\n        error(expression.left, \"Must have a value\");\n      }\n      const getRightValue = rightInfo.value;\n      if (!getRightValue) {\n        error(expression.right, \"Must have a value\");\n      }\n\n      const leftRegister = getRegisterForTypename(leftInfo.type);\n      const rightRegister = getRegisterForTypename(rightInfo.type);\n      if (!leftRegister) {\n        error(expression.left, \"Must have a value\");\n      }\n      if (!rightRegister) {\n        error(expression.right, \"Must have a value\");\n      }\n      if (leftRegister !== \"i32\") {\n        error(expression.left, \"TODO: Not suppoertted yet\");\n      }\n      if (rightRegister !== \"i32\") {\n        error(expression.right, \"TODO: Not suppoertted yet\");\n      }\n\n      const finalType = (() => {\n        if (leftInfo.type.type === \"pointer\") {\n          return leftInfo.type;\n        }\n        if (rightInfo.type.type === \"pointer\") {\n          return rightInfo.type;\n        }\n\n        const leftSize = getTypeSize(leftInfo.type);\n        const rightSize = getTypeSize(leftInfo.type);\n        if (leftSize.type !== \"static\") {\n          error(expression.left, \"Inernal error final type left\");\n        }\n        if (rightSize.type !== \"static\") {\n          error(expression.right, \"Inernal error final type left\");\n        }\n        if (leftSize.value >= rightSize.value) {\n          // TODO: Signed or unsigned!\n          return leftInfo.type;\n        } else {\n          return rightInfo.type;\n        }\n      })();\n\n      if (\n        op === \"*\" ||\n        op === \"/\" ||\n        op === \"%\" ||\n        op === \"+\" ||\n        op === \"-\" ||\n        op === \"&\" ||\n        op === \"|\" ||\n        op === \"<<\" ||\n        op === \">>\" ||\n        op === \"==\" ||\n        op === \"!=\" ||\n        op === \"<\" ||\n        op === \"<=\" ||\n        op === \">\" ||\n        op === \">=\" ||\n        op === \"^\"\n      ) {\n        const staticValue =\n          leftInfo.staticValue && rightInfo.staticValue\n            ? op === \"*\"\n              ? leftInfo.staticValue * rightInfo.staticValue\n              : op === \"/\"\n              ? Math.floor(leftInfo.staticValue / rightInfo.staticValue)\n              : op === \"%\"\n              ? leftInfo.staticValue % rightInfo.staticValue\n              : op === \"+\"\n              ? leftInfo.staticValue + rightInfo.staticValue\n              : op === \"-\"\n              ? leftInfo.staticValue - rightInfo.staticValue\n              : op === \"&\"\n              ? leftInfo.staticValue & rightInfo.staticValue\n              : op === \"|\"\n              ? leftInfo.staticValue | rightInfo.staticValue\n              : op === \">>\"\n              ? // TODO: signed or unsigned works differently\n                leftInfo.staticValue >> rightInfo.staticValue\n              : op === \"<<\"\n              ? leftInfo.staticValue << rightInfo.staticValue\n              : op === \"==\"\n              ? leftInfo.staticValue === rightInfo.staticValue\n                ? 1\n                : 0\n              : op === \"!=\"\n              ? leftInfo.staticValue !== rightInfo.staticValue\n                ? 1\n                : 0\n              : op === \"<\"\n              ? leftInfo.staticValue < rightInfo.staticValue\n                ? 1\n                : 0\n              : op === \"<=\"\n              ? leftInfo.staticValue <= rightInfo.staticValue\n                ? 1\n                : 0\n              : op === \">\"\n              ? leftInfo.staticValue > rightInfo.staticValue\n                ? 1\n                : 0\n              : op === \">=\"\n              ? leftInfo.staticValue >= rightInfo.staticValue\n                ? 1\n                : 0\n              : op === \"^\"\n              ? leftInfo.staticValue ^ rightInfo.staticValue\n              : assertNever(op)\n            : null;\n\n        const leftSigned =\n          leftInfo.type.type === \"arithmetic\" &&\n          leftInfo.type.signedUnsigned === \"signed\";\n        const rightSigned =\n          rightInfo.type.type === \"arithmetic\" &&\n          rightInfo.type.signedUnsigned === \"signed\";\n        const anySigned = leftSigned || rightSigned;\n        const finalSigned =\n          finalType.type === \"arithmetic\" &&\n          finalType.signedUnsigned === \"signed\";\n\n        const operatorInstructions: WAInstuction[] =\n          op === \"*\"\n            ? [\"i32.mul\"]\n            : op === \"/\"\n            ? finalSigned\n              ? [\"i32.div_s\"]\n              : [\"i32.div_u\"]\n            : op === \"%\"\n            ? finalSigned\n              ? [\"i32.rem_s\"]\n              : [\"i32.rem_u\"]\n            : op === \"+\"\n            ? [\"i32.add\"]\n            : op === \"-\"\n            ? [\"i32.sub\"]\n            : op === \"&\"\n            ? [\"i32.and\"]\n            : op === \"|\"\n            ? [\"i32.or\"]\n            : op === \"<<\"\n            ? [\"i32.shl\"]\n            : op === \">>\"\n            ? leftSigned\n              ? [\"i32.shr_s\"]\n              : [\"i32.shr_u\"]\n            : op === \"==\"\n            ? [\"i32.eq\"]\n            : op === \"!=\"\n            ? [\"i32.ne\"]\n            : op === \"<\"\n            ? anySigned\n              ? [\"i32.lt_s\"]\n              : [\"i32.lt_u\"]\n            : op === \"<=\"\n            ? anySigned\n              ? [\"i32.le_s\"]\n              : [\"i32.le_u\"]\n            : op === \">\"\n            ? anySigned\n              ? [\"i32.gt_s\"]\n              : [\"i32.gt_u\"]\n            : op === \">=\"\n            ? anySigned\n              ? [\"i32.ge_s\"]\n              : [\"i32.ge_u\"]\n            : op === \"^\"\n            ? [\"i32.xor\"]\n            : assertNever(op);\n\n        let rightMultiplyForPointerAddOrSub: WAInstuction[] = [];\n        if (\n          (op === \"+\" || op === \"-\") &&\n          leftInfo.type.type === \"pointer\" &&\n          rightInfo.type.type === \"arithmetic\"\n        ) {\n          const leftSize = getTypeSize(leftInfo.type.pointsTo);\n          if (leftSize.type !== \"static\") {\n            error(\n              expression.left,\n              \"DYnamic types are not supported yet, or incomplee is here\"\n            );\n          }\n          rightMultiplyForPointerAddOrSub = [\n            `i32.const ${leftSize.value}`,\n            `i32.mul`,\n          ];\n        }\n        if (\n          (op === \"+\" || op === \"-\") &&\n          leftInfo.type.type === \"arithmetic\" &&\n          rightInfo.type.type === \"pointer\"\n        ) {\n          error(expression, \"Not supported yet - swap arguments\");\n        }\n\n        return {\n          type: finalType,\n          staticValue: staticValue,\n          address: null,\n          value: () => {\n            return [\n              ...getLeftValue(),\n              ...getRightValue(),\n              ...rightMultiplyForPointerAddOrSub,\n              ...operatorInstructions,\n            ];\n          },\n        };\n      } else if (op === \"||\") {\n        return {\n          type: finalType,\n          staticValue: null,\n          address: null,\n          value: () => {\n            return [\n              // Expesssions have no break/continue/return statements\n              `block (result i32) ;; OR block`,\n              \"i32.const 1\",\n\n              ...getLeftValue(),\n              \"br_if 0\",\n              ...getRightValue(),\n              \"br_if 0\",\n\n              // Not very optimal\n              // Better to have two blocks\n              \"drop\",\n              \"i32.const 0\",\n\n              \"end\",\n            ];\n          },\n        };\n      } else if (op === \"&&\") {\n        return {\n          type: finalType,\n          staticValue: null,\n          address: null,\n          value: () => {\n            return [\n              // Expesssions have no break/continue/return statements\n              `block (result i32) ;; AND block`,\n              \"i32.const 0\",\n\n              ...getLeftValue(),\n              \"i32.eqz\",\n              \"br_if 0\",\n              ...getRightValue(),\n              \"i32.eqz\",\n              \"br_if 0\",\n\n              // Not very optimal\n              // Better to have two blocks\n              \"drop\",\n              \"i32.const 1\",\n\n              \"end\",\n            ];\n          },\n        };\n      } else {\n        assertNever(op);\n      }\n    } else if (expression.type === \"assignment\") {\n      const lvalueInfo = getExpressionInfo(expression.lvalue);\n      const rvalueInfo = getExpressionInfo(expression.rvalue);\n\n      const lvalueIsInRegister = getRegisterForTypename(lvalueInfo.type);\n      if (!lvalueIsInRegister) {\n        error(\n          expression.lvalue,\n          `Assignment to this type=${lvalueInfo.type} is not supported yet`\n        );\n      }\n\n      if (lvalueIsInRegister !== getRegisterForTypename(rvalueInfo.type)) {\n        // For example, i32 -> i64\n        error(\n          expression.rvalue,\n          `Type assigment ${rvalueInfo.type} to ${lvalueInfo.type} is not supported yet`\n        );\n      }\n\n      if (lvalueInfo.type.const) {\n        error(expression.lvalue, \"Have const modifier, unable to change\");\n      }\n\n      const getLvalueAddress = lvalueInfo.address;\n      if (!getLvalueAddress) {\n        error(expression.lvalue, \"Lvalue must have an address\");\n      }\n\n      const getLvalueValue = lvalueInfo.value;\n      if (!getLvalueValue) {\n        error(\n          expression.lvalue,\n          \"Lvalue must also have a value, at least for now\"\n        );\n      }\n\n      const getRvalueValue = rvalueInfo.value;\n      if (!getRvalueValue) {\n        error(expression.rvalue, \"rvalue must have a value, at least for now\");\n      }\n\n      const sideEffect = () => {\n        return [\n          ...getLvalueAddress(),\n          ...getRvalueValue(),\n          // We have no idea about alignment here - our lvalue address can be anything\n          // In the future we can pass \"is aligned\" via getExpressionInfo\n          storeScalar(lvalueInfo.type, lvalueIsInRegister, 0, 0),\n        ];\n      };\n\n      // not modifiable anymore\n      const newTypeNode: Typename = { ...lvalueInfo.type, const: true };\n      cloneLocation(lvalueInfo.type, newTypeNode);\n\n      return {\n        address: () => {\n          // This should be never used because we add \"const\" modifier\n          // And we now support only scalar values, so everything have value\n          return [...sideEffect(), ...getLvalueAddress()];\n        },\n        value: () => {\n          return [...sideEffect(), ...getLvalueValue()];\n        },\n        staticValue: null,\n        type: newTypeNode,\n      };\n      // Get address of lvalue\n      // Get value of rvalue (must be because in register)\n      // Place value in memory using lvalue type (char, short, int, etc)\n    } else if (expression.type === \"unary-operator\") {\n      if (expression.operator === \"&\") {\n        const target = expression.target;\n        const targetInfo = getExpressionInfo(target);\n        const getTargetAddress = targetInfo.address;\n        if (!getTargetAddress) {\n          error(expression.target, \"Must be something with address\");\n        }\n        const returnType: Typename = {\n          type: \"pointer\",\n          // Returned value is not an lvalue\n          const: true,\n          pointsTo: targetInfo.type,\n        };\n        cloneLocation(expression, returnType);\n        return {\n          type: returnType,\n          address: null,\n          staticValue: null,\n          value: getTargetAddress,\n        };\n      } else if (expression.operator === \"*\") {\n        const target = expression.target;\n        const targetInfo = getExpressionInfo(target);\n        if (targetInfo.type.type !== \"pointer\") {\n          error(target, `Must be a pointer`);\n        }\n        const targetValue = targetInfo.value;\n        if (!targetValue) {\n          error(target, `Must have a value`);\n        }\n\n        const pointsToType = targetInfo.type.pointsTo;\n        const pointsToRegister = getRegisterForTypename(pointsToType);\n\n        const getValue =\n          pointsToType.type === \"function\"\n            ? /* A special case for functions */\n              () => targetValue()\n            : pointsToRegister\n            ? () => [\n                ...targetValue(),\n                loadScalar(pointsToType, pointsToRegister),\n              ]\n            : null;\n        return {\n          type: pointsToType,\n          value: getValue,\n          staticValue: null,\n          address: targetValue,\n        };\n      } else if (\n        expression.operator === \"~\" ||\n        expression.operator === \"!\" ||\n        expression.operator === \"+\" ||\n        expression.operator === \"-\"\n      ) {\n        const targetInfo = getExpressionInfo(expression.target);\n        const targetRegister = getRegisterForTypename(targetInfo.type);\n        if (!targetRegister) {\n          error(expression.target, \"Must be a value\");\n        }\n        if (targetRegister !== \"i32\") {\n          error(\n            expression.target,\n            `Register ${targetRegister} is not supported yet`\n          );\n        }\n        const targetValue = targetInfo.value;\n        if (!targetValue) {\n          error(expression.target, \"Must have a value\");\n        }\n        const whatReallyToDo: WAInstuction[] =\n          expression.operator === \"~\"\n            ? [`i32.const 4294967295`, `i32.xor`]\n            : expression.operator === \"!\"\n            ? [`i32.eqz`]\n            : expression.operator === \"+\"\n            ? []\n            : expression.operator === \"-\"\n            ? [`i32.const 4294967295`, `i32.xor`, `i32.const 1`, `i32.add`]\n            : assertNever(expression.operator);\n\n        return {\n          // TODO: Add a \"signed\" if operator is \"-\"\n          type: targetInfo.type,\n          address: null,\n          // TODO\n          staticValue: null,\n          value: () => [...targetValue(), ...whatReallyToDo],\n        };\n      } else {\n        assertNever(expression.operator);\n        /*\n        error(\n          expression,\n          `TODO: This unary operator ${expression.operator} is not supported yet`\n        );\n        */\n      }\n    } else if (expression.type === \"sizeof expression\") {\n      const typename: Typename = {\n        type: \"arithmetic\",\n        arithmeticType: \"int\",\n        signedUnsigned: null,\n        const: true,\n      };\n      cloneLocation(expression, typename);\n      const info = getExpressionInfo(expression.expression);\n      const size = getTypeSize(info.type);\n      if (size.type === \"incomplete\") {\n        error(\n          expression.expression,\n          \"Unable to get size of expression with incomplete type\"\n        );\n      } else if (size.type === \"static\") {\n        return {\n          address: null,\n          staticValue: size.value,\n          type: typename,\n\n          value: () => [`i32.const ${size.value}`],\n        };\n      } else if (size.type === \"expression\") {\n        const sizeExpressionInfo = getExpressionInfo(size.expression);\n        const sizeExpressionValue = sizeExpressionInfo.value;\n        if (!sizeExpressionValue) {\n          error(\n            size.expression,\n            \"Internal error: unable to get expression value\"\n          );\n        }\n        return {\n          address: null,\n          staticValue: null,\n          type: typename,\n          value: sizeExpressionValue,\n        };\n      } else {\n        assertNever(size);\n      }\n    } else if (expression.type === \"sizeof typename\") {\n      const typenameSize = getTypeSize(expression.typename);\n      if (typenameSize.type !== \"static\") {\n        error(\n          expression.typename,\n          \"TODO: Not supported yet or incomplete type\"\n        );\n      }\n\n      const sizeValue = typenameSize.value;\n\n      const typename: Typename = {\n        type: \"arithmetic\",\n        arithmeticType: \"int\",\n        signedUnsigned: null,\n        const: true,\n      };\n      cloneLocation(expression, typename);\n      return {\n        type: typename,\n        staticValue: sizeValue,\n        address: null,\n        value: () => [`i32.const ${sizeValue}`],\n      };\n    } else if (expression.type === \"cast\") {\n      const targetInfo = getExpressionInfo(expression.target);\n      // TODO: Other casts, change register if needed\n      const targetRegister = getRegisterForTypename(targetInfo.type);\n      if (targetRegister !== \"i32\") {\n        error(expression.target, \"TODO: Such casts are not supported yet\");\n      }\n      if (targetRegister !== getRegisterForTypename(expression.typename)) {\n        error(expression.typename, \"TODO: Register change for casting\");\n      }\n      if (\n        expression.typename.type === \"arithmetic\" &&\n        expression.typename.arithmeticType !== \"int\"\n      ) {\n        error(\n          expression.typename,\n          \"TODO: downncasting/upcasting is not supported yet\"\n        );\n      }\n\n      return {\n        type: expression.typename,\n        staticValue: targetInfo.staticValue,\n        value: targetInfo.value,\n        address: targetInfo.address,\n      };\n    } else if (\n      expression.type === \"postfix ++\" ||\n      expression.type === \"postfix --\"\n    ) {\n      const isPlus = expression.type === \"postfix ++\";\n      const target = expression.target;\n      const targetInfo = getExpressionInfo(expression.target);\n      const targetRegister = getRegisterForTypename(targetInfo.type);\n      if (!targetRegister) {\n        error(target, \"Must be a real type or pointer\");\n      }\n      let howManyToAdd: number;\n      if (targetInfo.type.type === \"pointer\") {\n        const pointsToSize = getTypeSize(targetInfo.type.pointsTo);\n        if (pointsToSize.type !== \"static\") {\n          error(target, `TODO: Only compilation-time known size is supported`);\n        }\n        howManyToAdd = pointsToSize.value;\n      } else {\n        howManyToAdd = 1;\n      }\n      const targetValue = targetInfo.value;\n      if (!targetValue) {\n        error(target, \"Must have a vakue\");\n      }\n      const targetAddress = targetInfo.address;\n      if (!targetAddress) {\n        error(target, \"Not an lvalue\");\n      }\n      if (targetInfo.type.const) {\n        error(target, \"A const modifier is here\");\n      }\n      if (targetRegister !== \"i32\") {\n        error(target, \"Such register is not supported yet\");\n      }\n      return {\n        type: targetInfo.type,\n        address: null,\n        staticValue: null,\n        /* \n          NOTE: We are using target value and twice target address\n          If they have side-effects, then this side effect will run 3 times\n          Can we have something with side-effect as lvalue? Todo: check it\n        */\n        value: () => [\n          // First, we take a value\n          ...targetValue(),\n\n          // We will write back to this address\n          ...targetAddress(),\n\n          // And now we are reading from same address. TODO: How to \"tee\"?\n          ...targetAddress(),\n          // So, reading value from address above\n          loadScalar(targetInfo.type, targetRegister),\n          `i32.const ${howManyToAdd}`,\n          isPlus ? `i32.add` : \"i32.sub\",\n\n          storeScalar(targetInfo.type, targetRegister),\n        ],\n      };\n    } else if (\n      expression.type === \"prefix ++\" ||\n      expression.type === \"prefix --\"\n    ) {\n      const isPlus = expression.type === \"prefix ++\";\n      const target = expression.target;\n      const targetInfo = getExpressionInfo(expression.target);\n      const targetRegister = getRegisterForTypename(targetInfo.type);\n      if (!targetRegister) {\n        error(target, \"Must be a real type or pointer\");\n      }\n      let howManyToAdd: number;\n      if (targetInfo.type.type === \"pointer\") {\n        const pointsToSize = getTypeSize(targetInfo.type.pointsTo);\n        if (pointsToSize.type !== \"static\") {\n          error(target, `TODO: Only compilation-time known size is supported`);\n        }\n        howManyToAdd = pointsToSize.value;\n      } else {\n        howManyToAdd = 1;\n      }\n      const targetValue = targetInfo.value;\n      if (!targetValue) {\n        error(target, \"Must have a vakue\");\n      }\n      const targetAddress = targetInfo.address;\n      if (!targetAddress) {\n        error(target, \"Not an lvalue\");\n      }\n      if (targetInfo.type.const) {\n        error(target, \"A const modifier is here\");\n      }\n      if (targetRegister !== \"i32\") {\n        error(target, \"Such register is not supported yet\");\n      }\n      return {\n        type: targetInfo.type,\n        address: null,\n        staticValue: null,\n        /* \n          NOTE: We are using target value and twice target address\n          If they have side-effects, then this side effect will run 3 times\n          Can we have something with side-effect as lvalue? Todo: check it\n        */\n        value: () => [\n          // We will write back to this address\n          ...targetAddress(),\n\n          // And now we are reading from same address. TODO: How to \"tee\"?\n          ...targetAddress(),\n          // So, reading value from address above\n          loadScalar(targetInfo.type, targetRegister),\n          `i32.const ${howManyToAdd}`,\n          isPlus ? `i32.add` : \"i32.sub\",\n\n          storeScalar(targetInfo.type, targetRegister),\n\n          // And now we take a value\n          ...targetValue(),\n        ],\n      };\n    } else if (expression.type === \"conditional expression\") {\n      const conditionInfo = getExpressionInfo(expression.condition);\n      const iftrueInfo = getExpressionInfo(expression.iftrue);\n      const iffalseInfo = getExpressionInfo(expression.iffalse);\n\n      const conditionValue = conditionInfo.value;\n      if (!conditionValue) {\n        error(expression.condition, \"Condition must have a value\");\n      }\n\n      const iftrueValue = iftrueInfo.value;\n      if (!iftrueValue) {\n        error(expression.iftrue, \"Iftrue part must have a value\");\n      }\n\n      const iffalseValue = iffalseInfo.value;\n      if (!iffalseValue) {\n        error(expression.iftrue, \"Iffalse part must have a value\");\n      }\n\n      if (getRegisterForTypename(conditionInfo.type) !== \"i32\") {\n        error(expression.condition, \"Register is not supported\");\n      }\n      if (getRegisterForTypename(iftrueInfo.type) !== \"i32\") {\n        error(expression.condition, \"Register is not supported\");\n      }\n      if (getRegisterForTypename(iffalseInfo.type) !== \"i32\") {\n        error(expression.condition, \"Register is not supported\");\n      }\n\n      const finalType = (() => {\n        // todo: checks\n        const leftSize = getTypeSize(iftrueInfo.type);\n        const rightSize = getTypeSize(iffalseInfo.type);\n        if (leftSize.type !== \"static\") {\n          error(expression.iftrue, \"Inernal error final type left\");\n        }\n        if (rightSize.type !== \"static\") {\n          error(expression.iffalse, \"Inernal error final type left\");\n        }\n        if (leftSize.value >= rightSize.value) {\n          // TODO: Signed or unsigned!\n          return iftrueInfo.type;\n        } else {\n          return iffalseInfo.type;\n        }\n      })();\n\n      return {\n        type: finalType,\n        address: null,\n        staticValue: null,\n        value: () => [\n          ...conditionValue(),\n          `if (result i32)`,\n          ...iftrueValue(),\n          \"else\",\n          ...iffalseValue(),\n          \"end\",\n        ],\n      };\n      // asdasd\n      error(expression, \"TODO ME conditional expression\");\n    }\n\n    error(expression, `TODO other expressionInfo for type=${expression.type}`);\n  };\n\n  return {\n    getTypeSize,\n\n    getExpressionInfo,\n  };\n}\n","import { EmitterHelpers } from \"./emitter.helpers\";\nimport {\n  Node,\n  FunctionDefinition,\n  CompoundStatementBody,\n  Statement,\n} from \"./parser.definitions\";\nimport { WAInstuction } from \"./emitter.definitions\";\nimport {\n  getRegisterForTypename as getRegisterFromTypename,\n  writeEspCode,\n  readEspCode,\n} from \"./emitter.utils\";\nimport {\n  TypeSizeGetter,\n  ExpressionInfoGetter,\n} from \"./emitter.expressionsandtypes\";\nimport { assertNever } from \"./assertNever\";\nimport { storeScalar } from \"./emitter.scalar.storeload\";\n\n/**\n * Small helper to unwrap compound-statement\n */\nfunction statementToCompoundStatementBody(\n  statement: Statement\n): CompoundStatementBody[] {\n  if (statement.type === \"compound-statement\") {\n    return statement.body;\n  } else {\n    return [statement];\n  }\n}\n\nexport function createFunctionCodeGenerator(\n  helpers: EmitterHelpers,\n  getTypeSize: TypeSizeGetter,\n  getExpressionInfo: ExpressionInfoGetter\n) {\n  const { warn, getDeclaration } = helpers;\n\n  function error(node: Node, msg: string): never {\n    helpers.error(node, msg);\n  }\n\n  function createFunctionCode(func: FunctionDefinition): WAInstuction[] {\n    const functionTypename = helpers.functionSignatures.getFunctionTypeName(\n      func.declaration.typename\n    );\n\n    let inFuncAddress = 0;\n    for (const declarationId of func.declaredVariables) {\n      const declaration = getDeclaration(declarationId);\n      const size = getTypeSize(declaration.typename);\n      if (size.type !== \"static\") {\n        error(declaration, \"Dynamic or incomplete size is not supported yet\");\n      }\n      declaration.memoryOffset = inFuncAddress;\n      declaration.memoryIsGlobal = false;\n      inFuncAddress += size.value;\n    }\n\n    const functionReturnsInRegister = getRegisterFromTypename(\n      func.declaration.typename.returnType\n    );\n    if (\n      functionReturnsInRegister === null &&\n      func.declaration.typename.returnType.type !== \"void\"\n    ) {\n      error(\n        func.declaration.typename.returnType,\n        \"This return type is not supported yet\"\n      );\n    }\n\n    const returnValueLocalName = \"$return_value\";\n\n    function createFunctionCodeForBlock(\n      body: CompoundStatementBody[],\n      returnBrDepth: number,\n      continueBrDepth: number | null\n    ): WAInstuction[] {\n      const breakBrDepth =\n        continueBrDepth !== null ? continueBrDepth + 1 : null;\n      const code: WAInstuction[] = [];\n      let returnFound = false;\n      for (const statement of body) {\n        if (returnFound) {\n          warn(statement, \"Unreachable code detected\");\n          continue;\n        }\n\n        if (statement.type === \"noop\") {\n          code.push(\"nop ;; noop statement\");\n        } else if (statement.type === \"declarator\") {\n          // TODO: Dynamic arrays case\n\n          if (statement.initializer) {\n            if (statement.initializer.type === \"initializer-list\") {\n              error(statement.initializer, \"Not supported yet\");\n            } else if (statement.initializer.type === \"assigmnent-expression\") {\n              if (statement.memoryIsGlobal) {\n                continue;\n              }\n              const initializerInfo = getExpressionInfo(\n                statement.initializer.expression\n              );\n\n              if (!initializerInfo.value) {\n                error(statement.initializer.expression, \"Must return a value\");\n              }\n              code.push(\n                `;; Initializer for local ${statement.identifier} id=${statement.declaratorId}`,\n\n                // For declarators we do not have \"address\" function we duplicate code here\n                `local.get $ebp ;;  address, first part`,\n\n                ...initializerInfo.value(),\n                // Everything have 4-bytes alignment, so it is ok to load 8 bytes as i32\n                `i32.store offset=${statement.memoryOffset} align=2 `\n              );\n            } else {\n              assertNever(statement.initializer);\n            }\n          }\n        } else if (statement.type === \"return\") {\n          code.push(\";; return\");\n          if (func.declaration.typename.returnType.type === \"void\") {\n            if (statement.expression) {\n              error(\n                statement.expression,\n                \"void function should not return value\"\n              );\n            }\n            // Do not place anything on stack\n          } else {\n            if (!statement.expression) {\n              error(statement, \"Must be an expression here\");\n            }\n            const returnExpressionInfo = getExpressionInfo(\n              statement.expression\n            );\n\n            const expressionRegisterType = getRegisterFromTypename(\n              returnExpressionInfo.type\n            );\n\n            if (\n              expressionRegisterType &&\n              expressionRegisterType === functionReturnsInRegister\n            ) {\n              if (!returnExpressionInfo.value) {\n                error(\n                  statement.expression,\n                  `Internal error: Type ${returnExpressionInfo.type.type} must have value`\n                );\n              }\n              code.push(...returnExpressionInfo.value());\n              code.push(`local.set ${returnValueLocalName}`);\n            } else {\n              error(\n                statement.expression,\n                \"This return type is not supported yet\"\n              );\n            }\n          }\n\n          code.push(`br ${returnBrDepth} ;; Return`);\n          returnFound = true;\n        } else if (statement.type === \"expression\") {\n          const info = getExpressionInfo(statement.expression);\n          // Here we need only side effects\n          if (info.value) {\n            code.push(...info.value());\n          } else if (info.address) {\n            code.push(...info.address());\n          } else {\n            error(\n              statement.expression,\n              \"Internal error: expression must have value or address\"\n            );\n          }\n          if (info.type.type !== \"void\") {\n            code.push(\"drop\");\n          }\n        } else if (statement.type === \"compound-statement\") {\n          // Here is no need to create a block, but we do this just for simplicity\n          code.push(\"block ;; compound-statement\");\n          code.push(\n            ...createFunctionCodeForBlock(\n              statement.body,\n              returnBrDepth + 1,\n              continueBrDepth !== null ? continueBrDepth + 1 : null\n            )\n          );\n          code.push(\"end ;; compound-statement\");\n        } else if (statement.type === \"if\") {\n          const conditionInfo = getExpressionInfo(statement.condition);\n          const conditionRegister = getRegisterFromTypename(conditionInfo.type);\n          if (!conditionInfo.value) {\n            error(statement.condition, \"Condition must have a value\");\n          }\n          if (conditionRegister !== \"i32\") {\n            error(\n              statement.condition,\n              \"TODO: register change is not supported yet\"\n            );\n          }\n\n          code.push(\n            ...conditionInfo.value(),\n            \"if\",\n            ...createFunctionCodeForBlock(\n              statementToCompoundStatementBody(statement.iftrue),\n              returnBrDepth + 1,\n              continueBrDepth !== null ? continueBrDepth + 1 : null\n            )\n          );\n          if (statement.iffalse) {\n            code.push(\n              \"else\",\n              ...createFunctionCodeForBlock(\n                statementToCompoundStatementBody(statement.iffalse),\n                returnBrDepth + 1,\n                continueBrDepth !== null ? continueBrDepth + 1 : null\n              )\n            );\n          }\n          code.push(\"end\");\n        } else if (statement.type === \"while\") {\n          const conditionInfo = getExpressionInfo(statement.condition);\n          const conditionRegister = getRegisterFromTypename(conditionInfo.type);\n          if (!conditionInfo.value) {\n            error(statement.condition, \"Condition must have a value\");\n          }\n          if (conditionRegister !== \"i32\") {\n            error(\n              statement.condition,\n              \"TODO: This register type is not supported yet\"\n            );\n          }\n          code.push(\"block ;; while loop 1\", \"loop ;; while loop 2 \");\n\n          code.push(\";; Check while condition\");\n          code.push(...conditionInfo.value());\n          // zero is false, non-zero is true\n          // We should break if condition was falsy, so invert it\n          code.push(\"i32.eqz ;; Revert boolean\");\n          code.push(`br_if 1 ;; Breaking outer block`);\n\n          code.push(\n            ...createFunctionCodeForBlock(\n              statementToCompoundStatementBody(statement.body),\n              returnBrDepth + 2,\n              // A new loop is here\n              0\n            )\n          );\n\n          code.push(\n            \"br 0 ;; while loop, go to beginning\",\n            \"end ;; while loop, first end \",\n            \"end ;; while loop, second end\"\n          );\n        } else if (statement.type === \"dowhile\") {\n          error(statement, \"TODO: Do-while is not implemented yet\");\n        } else if (statement.type === \"break\") {\n          if (breakBrDepth === null) {\n            error(statement, `Unable to break - no loop`);\n          }\n          code.push(`br ${breakBrDepth}`);\n        } else if (statement.type === \"continue\") {\n          if (continueBrDepth === null) {\n            error(statement, \"Unable to continue - no loop\");\n          }\n          code.push(`br ${continueBrDepth}`);\n        } else {\n          assertNever(statement);\n        }\n      }\n\n      return code;\n    }\n\n    const funcCode: WAInstuction[] = createFunctionCodeForBlock(\n      func.body,\n      0,\n      null\n    );\n\n    const restoreEsp: WAInstuction[] = [...writeEspCode([`local.get $ebp`])];\n    const returnValueInRegisterIfAny: WAInstuction[] = functionReturnsInRegister\n      ? [`local.get ${returnValueLocalName}`]\n      : [];\n\n    const functionParamsDeclarations: WAInstuction[] = [];\n    const functionParamsInitializers: WAInstuction[] = [];\n    for (const param of func.declaration.typename.parameters) {\n      if (param.type !== \"declarator\") {\n        error(\n          param,\n          `Internal error: function must have declarator parameters`\n        );\n      }\n      const paramRegisterType = getRegisterFromTypename(param.typename);\n      if (!paramRegisterType) {\n        error(param, \"TODO: Currently this type of parameter is not supported\");\n      }\n      functionParamsDeclarations.push(\n        `  (param $P${param.declaratorId} ${paramRegisterType}) `\n      );\n\n      functionParamsInitializers.push(\n        // Parameter address. They are always on stack\n        // Load ebp here and add it to memoryoffset\n        `local.get $ebp ;; Param ${param.identifier} ebp`,\n        // Parameter value\n        `local.get $P${param.declaratorId} ;; Param ${param.identifier} value`,\n\n        // Parameters are aligned because they are on stack\n        storeScalar(param.typename, paramRegisterType, param.memoryOffset, 2)\n      );\n    }\n\n    // Why is this? It works without this too\n    const funcTypeHint = `(type ${functionTypename})`;\n\n    const functionHeader =\n      `(func $F${func.declaration.declaratorId} ` +\n      funcTypeHint +\n      functionParamsDeclarations.join(\" \") +\n      (functionReturnsInRegister\n        ? ` (result ${functionReturnsInRegister})`\n        : \"\") +\n      `  (local $ebp i32)` +\n      (functionReturnsInRegister\n        ? `  (local ${returnValueLocalName} ${functionReturnsInRegister})`\n        : \"\");\n\n    return [\n      `;; Function ${func.declaration.identifier} localSize=${inFuncAddress}`,\n      functionHeader,\n\n      ...readEspCode,\n      `local.set $ebp ;; Save esp -> ebp`,\n\n      ...writeEspCode([\n        `local.get $ebp`,\n        `i32.const ${inFuncAddress}`,\n        `i32.add ;; Add all locals to esp`,\n      ]),\n      `;; Initialize params`,\n      ...functionParamsInitializers,\n      `;; Function body`,\n      `block ;; main function block `,\n      ...funcCode,\n      \"end ;; main function block end\",\n      `;; Cleanup`,\n      ...restoreEsp,\n      ...returnValueInRegisterIfAny,\n      `)`,\n      \"\",\n      `(export \"${func.declaration.identifier}\" (func $F${func.declaration.declaratorId}))`,\n      \"\",\n    ];\n  }\n\n  return {\n    createFunctionCode,\n  };\n}\n","import { FunctionTypename } from \"./parser.definitions\";\nimport { WAInstuction } from \"./emitter.definitions\";\nimport { FunctionSignatures } from \"./emitter.helpers.functionsignature\";\n\nconst trapFunctionType: FunctionTypename = {\n  type: \"function\",\n  returnType: {\n    type: \"void\",\n    const: true,\n  },\n  const: true,\n  haveEndingEllipsis: false,\n  parameters: [],\n};\n\nexport const trapFunctionName = \"$null\";\nexport function getTrapFunctionCode(\n  functionSignatures: FunctionSignatures\n): WAInstuction[] {\n  const waTypeName = functionSignatures.getFunctionTypeName(trapFunctionType);\n  return [`(func ${trapFunctionName} (type ${waTypeName})`, `unreachable`, `)`];\n}\n","import { TranslationUnit, Node } from \"./parser.definitions\";\n\nimport { WAInstuction } from \"./emitter.definitions\";\nimport { writeEspCode, readEspCode } from \"./emitter.utils\";\nimport { createHelpers } from \"./emitter.helpers\";\nimport { createExpressionAndTypes } from \"./emitter.expressionsandtypes\";\nimport { createFunctionCodeGenerator } from \"./emitter.functionscode\";\nimport { getTrapFunctionCode } from \"./emitter.helpers.trap\";\n\nfunction cacheFunc<T, U>(func: (param1: T) => U): (param1: T) => U {\n  const cache = new Map<T, U>();\n  return (param1) => {\n    const cached = cache.get(param1);\n    if (cached) {\n      return cached;\n    } else {\n      const value = func(param1);\n      cache.set(param1, value);\n      return value;\n    }\n  };\n}\n\nexport function emit(unit: TranslationUnit) {\n  const locator = unit.locationMap();\n  const declaratorMap = unit.declaratorMap();\n\n  const helpers = createHelpers(locator, declaratorMap);\n\n  const { warn, getDeclaration, warnings } = helpers;\n\n  function error(node: Node, msg: string): never {\n    helpers.error(node, msg);\n    throw new Error(\"Typescript workaround\");\n  }\n\n  const { getTypeSize, getExpressionInfo } = createExpressionAndTypes(helpers);\n\n  const { createFunctionCode } = createFunctionCodeGenerator(\n    helpers,\n    getTypeSize,\n    getExpressionInfo\n  );\n\n  // Initial step: assign global memory\n  let memoryOffsetForGlobals = 8; // 4 for move from 0 address, and 0x4 for esp\n\n  let functionIdAddress = 1;\n  const globalsInitializers: WAInstuction[] = [];\n  for (const declarationId of unit.declarations) {\n    const declaration = getDeclaration(declarationId);\n    if (declaration.storageSpecifier === \"typedef\") {\n      continue;\n    }\n\n    if (declaration.typename.type === \"function\") {\n      declaration.memoryOffset = functionIdAddress;\n      functionIdAddress++;\n      continue;\n    }\n\n    if (declaration.typename.type === \"function-knr\") {\n      throw new Error(\"No K&R here\");\n    }\n    if (declaration.typename.type === \"void\") {\n      error(declaration, \"Void for variable is not allowed\");\n    }\n    const size = getTypeSize(declaration.typename);\n    if (size.type !== \"static\") {\n      error(declaration, `Globals must have known size`);\n    }\n    if (memoryOffsetForGlobals % 4 !== 0) {\n      throw new Error(\"Self-check failed, wrong alignment\");\n    }\n    declaration.memoryOffset = memoryOffsetForGlobals;\n    declaration.memoryIsGlobal = true;\n    memoryOffsetForGlobals += size.value;\n    const alignment = memoryOffsetForGlobals % 4;\n    if (alignment !== 0) {\n      memoryOffsetForGlobals += 4 - alignment;\n    }\n\n    if (declaration.initializer) {\n      if (declaration.typename.type === \"arithmetic\") {\n        if (declaration.initializer.type !== \"assigmnent-expression\") {\n          error(\n            declaration.initializer,\n            \"Wrong iniializer for arithmetic type\"\n          );\n        }\n\n        const initializerExpressionInfo = getExpressionInfo(\n          declaration.initializer.expression\n        );\n        if (initializerExpressionInfo.type.type !== \"arithmetic\") {\n          error(declaration.initializer.expression, \"Must be arithmetic\");\n        }\n        if (initializerExpressionInfo.staticValue === null) {\n          error(\n            declaration.initializer.expression,\n            \"Initializer value must be known on compilation time\"\n          );\n        }\n        if (\n          initializerExpressionInfo.type.arithmeticType !== \"int\" &&\n          initializerExpressionInfo.type.arithmeticType !== \"char\"\n        ) {\n          error(\n            declaration.initializer.expression,\n            \"TODO: Only int or char is supported for initializers\"\n          );\n        }\n\n        globalsInitializers.push(\n          `;; Initializer for global ${declaration.identifier} id=${declaration.declaratorId}`,\n          // For declarators we do not have \"address\" function we duplicate code here\n          `i32.const ${declaration.memoryOffset} ;; global address`,\n          `i32.const ${initializerExpressionInfo.staticValue} ;; value`,\n          // Everything have 4-bytes alignment, so it is ok to load 8 bytes as i32\n          `i32.store offset=0 align=2 `\n        );\n      }\n    }\n  }\n\n  /*\n  console.info(\n    `Globals size = ${\n      memoryOffsetForGlobals - 4\n    }, usable memory from ${memoryOffsetForGlobals}`\n  );\n  */\n\n  // first function is trap function\n\n  const functionsCode: WAInstuction[] = [];\n  // Now create functions\n  for (const statement of unit.body) {\n    if (statement.type === \"function-declaration\") {\n      const lines = createFunctionCode(statement);\n      functionsCode.push(...lines);\n    }\n  }\n\n  const setupEsp: WAInstuction[] = [\n    ...writeEspCode([`i32.const ${memoryOffsetForGlobals} ;; Prepare esp`]),\n  ];\n\n  const debugHelpers: WAInstuction[] = [\n    `(func (export \"_debug_get_esp\") (result i32)`,\n    ...readEspCode,\n    \")\",\n  ];\n\n  const trapFunctionCode = getTrapFunctionCode(helpers.functionSignatures);\n\n  const functionTypes = helpers.functionSignatures.getTypesWAInstructions();\n\n  const functionTable: WAInstuction[] = [\n    `(table ${functionIdAddress} ${functionIdAddress} anyfunc) ;; min and max length`,\n    `(elem (i32.const 0) $null ` +\n      unit.body\n        .map((statement) => {\n          if (statement.type !== \"function-declaration\") {\n            return \"\";\n          }\n          return ` $F${statement.declaration.declaratorId}`;\n        })\n        .join(\"\") +\n      \")\",\n  ];\n\n  const moduleCode: WAInstuction[] = [\n    \"(module\",\n    `(import \"js\" \"memory\" (memory 0))`,\n\n    ...functionTypes,\n\n    ...functionTable,\n\n    //'(global $esp (import \"js\" \"esp\") (mut i32))',\n    //\"(global $esp (mut i32))\",\n\n    // Functions are in order of definition (not declaration?)\n    ...trapFunctionCode,\n    ...functionsCode,\n\n    \" (func $init  \",\n    ...setupEsp,\n    ...globalsInitializers,\n    \")\",\n    \" (start $init)\",\n\n    ...debugHelpers,\n    \")\",\n  ];\n\n  return {\n    warnings,\n    moduleCode,\n  };\n}\n","import {\n  TranslationUnit,\n  FunctionDefinition,\n  DeclaratorNode,\n} from \"../core/parser.definitions\";\n\nexport function writeAst(unit: TranslationUnit, write: (msg: string) => void) {\n  const [header, lines] = writeNode(unit);\n  write(header);\n  lines.forEach((l) => write(l));\n}\n\nfunction writeNode(node: any): [string, string[]] {\n  if (node === null || node === undefined) {\n    return [\"\", []];\n  }\n\n  const lines: string[] = [];\n\n  if (Array.isArray(node)) {\n    let customLine = \"\";\n    node.forEach((n) => {\n      if (typeof n === \"string\") {\n        customLine += `  ${n}`;\n      } else {\n        const arrNode = writeNode(n);\n        lines.push(`  - ${arrNode[0]}`);\n        lines.push(...arrNode[1].map((l) => `    ${l}`));\n      }\n    });\n    if (customLine) {\n      lines.push(customLine);\n    }\n\n    return [\"\", lines];\n  }\n\n  if (!node.type) {\n    return [\"\", []];\n  }\n  let header = `${node.type}`;\n  header = header.slice(0, 1).toUpperCase() + header.slice(1);\n  header = header.replace(/ /g, \"_\").replace(/-/g, \"_\");\n\n  const keys = Object.keys(node).filter((x) => x !== \"type\");\n\n  keys.forEach((k) => {\n    const v = node[k];\n    const t = typeof v;\n\n    if (v === null || t === \"undefined\") {\n      // nothing here\n    } else if (t === \"string\" || t === \"number\" || t === \"boolean\") {\n      header += ` ${k}=${v}`;\n    } else if (t === \"object\") {\n      lines.push(`  ${k}:`);\n      const [childHeader, childText] = writeNode(v);\n      if (childHeader) {\n        lines.push(`    ${childHeader}`);\n        lines.push(...childText.map((l) => `    ${l}`));\n      } else {\n        lines.push(...childText.map((l) => `  ${l}`));\n      }\n    }\n  });\n\n  return [header, lines];\n}\n","import { readFileSync } from \"fs\";\nimport { Scanner } from \"../core/scanner\";\nimport { createScannerFunc } from \"../core/scanner.func\";\nimport { readTranslationUnit } from \"../core/parser\";\nimport { emit } from \"../core/emitter\";\nimport { writeEspCode } from \"../core/emitter.utils\";\nimport pad from \"pad\";\nimport { writeAst } from \"./ast\";\n\nconst aesCode = readFileSync(__dirname + \"/../test/emitter.aes.c\").toString();\nconst crc32Code = readFileSync(\n  __dirname + \"/../test/emitter.crc32.c\"\n).toString();\nconst simpleExampleCode = readFileSync(\n  __dirname + \"/simple_example.c\"\n).toString();\n\nconst textArea = document.getElementById(\"src\") as HTMLTextAreaElement;\n\n(document.getElementById(\"compile\") as HTMLButtonElement).onclick = go;\n\nconst main1 = document.getElementById(\"main1\") as HTMLDivElement;\nconst main2 = document.getElementById(\"main2\") as HTMLDivElement;\nconst logDiv = document.getElementById(\"log\") as HTMLDivElement;\n\nfunction write(msg: string) {\n  const el = document.createElement(\"div\");\n  el.innerHTML = msg;\n  logDiv.appendChild(el);\n}\n\n(document.getElementById(\"back\") as HTMLButtonElement).onclick = () => {\n  logDiv.innerHTML = \"\";\n\n  main1.style.display = \"\";\n\n  main2.style.display = \"none\";\n};\n\n(document.getElementById(\"load_simple\") as HTMLButtonElement).onclick = () => {\n  textArea.value = simpleExampleCode;\n};\n(document.getElementById(\"load_aes\") as HTMLButtonElement).onclick = () => {\n  textArea.value = aesCode;\n};\n(document.getElementById(\"load_crc32\") as HTMLButtonElement).onclick = () => {\n  textArea.value = crc32Code;\n};\n\nfunction go() {\n  const input = textArea.value;\n\n  main1.style.display = \"none\";\n\n  main2.style.display = \"\";\n\n  write(\"=== Source file ===\");\n  input\n    .split(\"\\n\")\n    .forEach((line, idx) => write(`${pad(`${idx + 1}`, 5, \" \")}   ${line}`));\n\n  try {\n    const scanner = new Scanner(createScannerFunc(input));\n\n    const unit = readTranslationUnit(scanner);\n\n    const emitted = emit(unit);\n\n    if (emitted.warnings.length > 0) {\n      write(\"Warnings:\");\n      emitted.warnings.forEach((w) =>\n        write(`  ${w.msg} at ${w.line}:${w.pos}`)\n      );\n    }\n\n    //TODO: Write ast\n    write(\" \");\n    write(\"=== ast ===\");\n    writeAst(unit, write);\n\n    write(\" \");\n    write(\"=== WebAssembly text ===\");\n    emitted.moduleCode.forEach((line) => write(line));\n  } catch (e) {\n    const err = {\n      name: e.name,\n      message: e.message,\n      line: e.location.line,\n      pos: e.location.pos,\n      length: e.location.length,\n    };\n    write(\n      `${err.name} ${err.message} at ${err.line}:${err.pos} len=${err.length}`\n    );\n    write(\"\");\n    write(e.stack);\n  }\n}\n\ntextArea.value = simpleExampleCode;\n\n// Demoing\n// setTimeout(() => go(), 1);\n"]}